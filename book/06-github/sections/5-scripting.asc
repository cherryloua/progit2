=== Pag-iiskrip sa GitHub

At ngayong natalakay na natin ang lahat ng mga pangunahing tampok at workflow ng GitHub, ngunit anumang malaking grupo o proyekto ay magkakaroon ng mga pasadya na gusto nila na gawin o mga serbisyo na panlabas na gusto nilang isama.

Sa kabutihang-palad para sa atin, ang GitHub ay talagang lubos na maaaring i-hack sa maraming paraan.
Sa seksyong ito, tatalakayon natin kung paano gamitin ang sistema ng mga hook ng GitHub at ang API nito upang gawin ang GitHub na gumana ayon sa gusto natin.

==== Mga Serbisyo at mga Hook

Ang seksyon ng mga Hook at mga Serbisyo ng pag-aadministrabo sa repositoryo ng GitHub ay ang pinakamadaling paraan upang makipag-ugnay ang GitHub sa mga panlabas na sistema.

===== Mga Serbisyo

Una nating tingnan ang mga Serbisyo.
Ang parehong mga pagsasama ng mga Hook at Serbisyo ay matatagpuan sa seksyon ng mga Setting ng iyong repositoryo, kung saan dati nating natingnan sa pagdaragdag ng mga Tagatulong at pagbabago ng default na branch ng iyong proyekto.
Sa ilalim ng tab na ``Mga Webhook at mga Serbisyo'' makikita natin ang isang bagay tulad ng <<_services_hooks>>.

[[_services_hooks]]
.Seksyon ng pagsasaayos sa mga Serbisyo at mga Hook.
image::images/scripting-01-services.png[Mga serbisyo at mga hook]

Mayroong dose-dosenang mga serbisyo ang maaari mong pagpipilian, karamihan sa mga ito ay mga pagsasama sa iba pang mga komersyal at mga sistema na open ssource.
Karamihan sa kanila ay para sa mga serbisyo ng Patuloy na Pagsasama, bug, at mga tracker ng isyu, mga sistema ng chat room at mga sistema ng dokumentasyon.
Tatalakayin natin ang pag-set up ng isang napaka-simple, ang hook ng Email.
Kung pipiliin mo ang ``email'' mula sa dropdown na ``Magdagdag ng Serbisyo'', makakakuha ng isang screen ng pagsasaayos tulad ng <<_service_config>>.

[[_service_config]]
.Pagsasaayos ng serbisyo ng Email.
image::images/scripting-02-email-service.png[Serbisyo ng email]

Sa kasong ito, kung pinindot natin ang pindutan na ``Magdagdag ng serbisyo'', ang tinukoy natin na email address ay makakakuha ng isang email sa tuwing may isang tao ang nag-push sa repositoryo.
Ang mga serbisyo ay maaaring makinig para sa maraming iba't-ibang uri ng mga kaganapan, ngunit karamihan lamang ay makinig para sa mga push na mga kaganapan at pagkatapos ay gawin ang isang bagay sa datos na iyon.

Kung mayroong isang sistema na iyong ginagamit na nais mong isama sa GitHub, dapat mong suriin dito upang makita kung mayroong umiiral na magagamit na pagsasama ng serbisyo.
Halimbawa, kung gumagamit ka ng Jenkins upang magpatakbo ng mga pagsusuri sa iyong codebase, maaari mong paganahin ang pagsasama ng Jenkins builtin na serbisyo upang mag-umpisa ng isang patakbuhing pagsusuri sa tuwing may isang taong nag-push sa iyong repositoryo.

===== Mga Hook

Kung kailangan mo ng isang bagay na mas tiyak o nais mong isama sa isang serbisyo o site na hindi nabibilang sa listahang ito, maaari mong gamitin sa halip ang mas panlahat na sistema ng mga hook.
Ang mga hook sa repositoryo ng GitHub ay simple lamang.
Magtukoy ka ng isang URL at ipapaskil ng GitHub ang isang payload na HTTP sa URL na iyon sa anumang kaganapan na nais mo.

Sa pangkalahatan, ang paraan ng paggana nito ay maaari mong i-setup ang isang maliit na serbisyo sa web upang makinig para sa isang payload sa hook ng GitHub at pagkatapos ay gawin ang isang bagay sa datos kapag ito ay natanggap.

Upang magpagana ng isang hook, i-click ang pindutan na ``Magdagdag ng webhook'' sa <<_services_hooks>>.
Ito ay magdadala sa iyo sa isang pahina na katulad ng <<_web_hook>>.

[[_web_hook]]
.Pagsasaayos sa hook ng web.
image::images/scripting-03-webhook.png[Hook ng web]

Ang pagsasaayos para sa isang hook ng web ay simple lamang.
Karamihan sa mga kaso, ipasok mo lamang ang isang URL at isang sekretong key at pindutin ang ``Magdagdag ng webhook''.
May ilang mga opsyon para sa kung aling mga kaganapan ang gusto mong saan ipadala sa iyo ng GitHub ang isang kargamento - ang default ay upang makakuha lamang ng isang kargamento para sa `push` na kaganapan, kapag ang isang tao ay nag-push ng bagong code sa anumang branch ng iyong repositoryo.

Tingnan natin ang isang maliit na halimbawa ng isang serbisyo sa web na maaari mong i-set up upang mahawakan ang isang hook ng web.
Gagamitin natin ang balangkas na Sinatra ng web na Ruby dahil ito ay medyo maigsi at dapat mong madaling makita kung ano ang ginagawa natin.

Sabihin nating nais nating makakuha ng isang email kung ang isang partikular na tao ay nag-push sa isang partikular na branch ng ating proyekto na nagbabago sa isang partikular na file.
Maaari nating madaling gawin ito na may code tulad nito:

[source,ruby]
----
require 'sinatra'
require 'json'
require 'mail'

post '/payload' do
  push = JSON.parse(request.body.read) # i-parse ang JSON

  # tipunin ang datos na ating hinahanap
  pusher = push["pusher"]["name"]
  branch = push["ref"]

  # kumuha ng isang listahan ng lahat ng mga file na hinawakan
  files = push["commits"].map do |commit|
    commit['added'] + commit['modified'] + commit['removed']
  end
  files = files.flatten.uniq

  # suriin para sa ating pamantayan
  if pusher == 'schacon' &&
     branch == 'ref/heads/special-branch' &&
     files.include?('special-file.txt')

    Mail.deliver do
      from     'tchacon@example.com'
      to       'tchacon@example.com'
      subject  'Scott Changed the File'
      body     "ALARM"
    end
  end
end
----

Dito, kinukuha natin ang kargamento ng JSON na inilulunsad ng GitHub sa atin at hinahanap kung sino ang nag-push nito, kung anong branch sila nag-push at kung anu-ano ang mga file sa lahat ng mga gawaing na-push.
Pagkatapos ay sinusuri natin laban sa pamantayan at nagpadala ng isang email kung ito ay tumutugma.

In order to develop and test something like this, you have a nice developer console in the same screen where you set the hook up.
You can see the last few deliveries that GitHub has tried to make for that webhook.
For each hook you can dig down into when it was delivered, if it was successful and the body and headers for both the request and the response.
This makes it incredibly easy to test and debug your hooks.

[[_web_hook_debug]]
.Web hook debugging information.
image::images/scripting-04-webhook-debug.png[Webhook debug]

The other great feature of this is that you can redeliver any of the payloads to test your service easily.

For more information on how to write webhooks and all the different event types you can listen for, go to the GitHub Developer documentation at https://developer.github.com/webhooks/

==== The GitHub API

(((GitHub, API)))
Services and hooks give you a way to receive push notifications about events that happen on your repositories, but what if you need more information about these events?
What if you need to automate something like adding collaborators or labeling issues?

This is where the GitHub API comes in handy.
GitHub has tons of API endpoints for doing nearly anything you can do on the website in an automated fashion.
In this section we'll learn how to authenticate and connect to the API, how to comment on an issue and how to change the status of a Pull Request through the API.

==== Basic Usage

The most basic thing you can do is a simple GET request on an endpoint that doesn't require authentication.
This could be a user or read-only information on an open source project.
For example, if we want to know more about a user named ``schacon'', we can run something like this:

[source,javascript]
----
$ curl https://api.github.com/users/schacon
{
  "login": "schacon",
  "id": 70,
  "avatar_url": "https://avatars.githubusercontent.com/u/70",
# â€¦
  "name": "Scott Chacon",
  "company": "GitHub",
  "following": 19,
  "created_at": "2008-01-27T17:19:28Z",
  "updated_at": "2014-06-10T02:37:23Z"
}
----

There are tons of endpoints like this to get information about organizations, projects, issues, commits -- just about anything you can publicly see on GitHub.
You can even use the API to render arbitrary Markdown or find a `.gitignore` template.

[source,javascript]
----
$ curl https://api.github.com/gitignore/templates/Java
{
  "name": "Java",
  "source": "*.class

# Mobile Tools for Java (J2ME)
.mtj.tmp/

# Package Files #
*.jar
*.war
*.ear

# virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xml
hs_err_pid*
"
}
----


==== Commenting on an Issue

However, if you want to do an action on the website such as comment on an Issue or Pull Request or if you want to view or interact with private content, you'll need to authenticate.

There are several ways to authenticate.
You can use basic authentication with just your username and password, but generally it's a better idea to use a personal access token.
You can generate this from the ``Applications'' tab of your settings page.

[[_access_token]]
.Generate your access token from the ``Applications'' tab of your settings page.
image::images/scripting-05-access-token.png[Access Token]

It will ask you which scopes you want for this token and a description.
Make sure to use a good description so you feel comfortable removing the token when your script or application is no longer used.

GitHub will only show you the token once, so be sure to copy it.
You can now use this to authenticate in your script instead of using a username and password.
This is nice because you can limit the scope of what you want to do and the token is revocable.

This also has the added advantage of increasing your rate limit.
Without authenticating, you will be limited to 60 requests per hour.
If you authenticate you can make up to 5,000 requests per hour.

So let's use it to make a comment on one of our issues.
Let's say we want to leave a comment on a specific issue, Issue #6.
To do so we have to do an HTTP POST request to `repos/<user>/<repo>/issues/<num>/comments` with the token we just generated as an Authorization header.

[source,javascript]
----
$ curl -H "Content-Type: application/json" \
       -H "Authorization: token TOKEN" \
       --data '{"body":"A new comment, :+1:"}' \
       https://api.github.com/repos/schacon/blink/issues/6/comments
{
  "id": 58322100,
  "html_url": "https://github.com/schacon/blink/issues/6#issuecomment-58322100",
  ...
  "user": {
    "login": "tonychacon",
    "id": 7874698,
    "avatar_url": "https://avatars.githubusercontent.com/u/7874698?v=2",
    "type": "User",
  },
  "created_at": "2014-10-08T07:48:19Z",
  "updated_at": "2014-10-08T07:48:19Z",
  "body": "A new comment, :+1:"
}
----

Now if you go to that issue, you can see the comment that we just successfully posted as in <<_api_comment>>.

[[_api_comment]]
.A comment posted from the GitHub API.
image::images/scripting-06-comment.png[API Comment]

You can use the API to do just about anything you can do on the website -- creating and setting milestones, assigning people to Issues and Pull Requests, creating and changing labels, accessing commit data, creating new commits and branches, opening, closing or merging Pull Requests, creating and editing teams, commenting on lines of code in a Pull Request, searching the site and on and on.

==== Changing the Status of a Pull Request

There is one final example we'll look at since it's really useful if you're working with Pull Requests.
Each commit can have one or more statuses associated with it and there is an API to add and query that status.

Most of the Continuous Integration and testing services make use of this API to react to pushes by testing the code that was pushed, and then report back if that commit has passed all the tests.
You could also use this to check if the commit message is properly formatted, if the submitter followed all your contribution guidelines, if the commit was validly signed -- any number of things.

Let's say you set up a webhook on your repository that hits a small web service that checks for a `Signed-off-by` string in the commit message.

[source,ruby]
----
require 'httparty'
require 'sinatra'
require 'json'

post '/payload' do
  push = JSON.parse(request.body.read) # parse the JSON
  repo_name = push['repository']['full_name']

  # look through each commit message
  push["commits"].each do |commit|

    # look for a Signed-off-by string
    if /Signed-off-by/.match commit['message']
      state = 'success'
      description = 'Successfully signed off!'
    else
      state = 'failure'
      description = 'No signoff found.'
    end

    # post status to GitHub
    sha = commit["id"]
    status_url = "https://api.github.com/repos/#{repo_name}/statuses/#{sha}"

    status = {
      "state"       => state,
      "description" => description,
      "target_url"  => "http://example.com/how-to-signoff",
      "context"     => "validate/signoff"
    }
    HTTParty.post(status_url,
      :body => status.to_json,
      :headers => {
        'Content-Type'  => 'application/json',
        'User-Agent'    => 'tonychacon/signoff',
        'Authorization' => "token #{ENV['TOKEN']}" }
    )
  end
end
----

Hopefully this is fairly simple to follow.
In this web hook handler we look through each commit that was just pushed, we look for the string 'Signed-off-by' in the commit message and finally we POST via HTTP to the `/repos/<user>/<repo>/statuses/<commit_sha>` API endpoint with the status.

In this case you can send a state ('success', 'failure', 'error'), a description of what happened, a target URL the user can go to for more information and a ``context'' in case there are multiple statuses for a single commit.
For example, a testing service may provide a status and a validation service like this may also provide a status -- the ``context'' field is how they're differentiated.

If someone opens a new Pull Request on GitHub and this hook is set up, you may see something like <<_commit_status>>.

[[_commit_status]]
.Commit status via the API.
image::images/scripting-07-status.png[Commit status]

You can now see a little green check mark next to the commit that has a ``Signed-off-by'' string in the message and a red cross through the one where the author forgot to sign off.
You can also see that the Pull Request takes the status of the last commit on the branch and warns you if it is a failure.
This is really useful if you're using this API for test results so you don't accidentally merge something where the last commit is failing tests.

==== Octokit

Though we've been doing nearly everything through `curl` and simple HTTP requests in these examples, several open-source libraries exist that make this API available in a more idiomatic way.
At the time of this writing, the supported languages include Go, Objective-C, Ruby, and .NET.
Check out http://github.com/octokit[] for more information on these, as they handle much of the HTTP for you.

Hopefully these tools can help you customize and modify GitHub to work better for your specific workflows.
For complete documentation on the entire API as well as guides for common tasks, check out https://developer.github.com[].
