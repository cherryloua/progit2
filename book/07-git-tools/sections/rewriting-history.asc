[[_rewriting_history]]
=== Pagsulat muli ng Kasaysayan

Maraming beses, kapag ikaw ay nagtratrabaho gamit ang Git, baka gusto mong baguhin ang iyong lokal commit na kasaysayan.
Isa sa dakilang mga bagay tungkol sa Git ay nagbibigay-daan ito sa iyo upang gumawa ng mga desisyon sa huling posibleng sandali.
Maaari kang magpasya kung anong mga file ang papunta sa kung saang mga commit bago ka magsagawa ng commit sa stanging na lugar, maaari kang magpasya na hindi ibig sabihin na ikaw ay nagtratrabaho sa isang bagay pa gamit ang `git stash`, at maaari mong muling isulat ang mga commit na nangyari na para sila ay magmukha na nangyari sa ibang paraan.
Maaaring sangkot ang pagbabagot ng pagkasunod-sunod ng mga commit, pagbabago ng mga mensahe o pagbabago ng mga file sa isang commit, pag-squash nang magkasama o paghihiwalay na mga commit, o ang pag-alis ng mga commit sa lahat -- lahat ng bago mo ibahagi sa iyong trabaho sa iba.

Sa seksyon ito, makikita mo kung paaano gagawin ang mga gawaing ito upang makagawa ka ng iyong kasaysayan na magmukha sa gusto mong unang iyong ibinahagi sa iba.

[TANDAAN]
====
Isa sa kardinal na mga patakaran sa Git ay ang, mula ng maraming trabaho ay ang lokal na nasa loob ng iyong clone, meron kang isang magandang pakikitungo sa kalayaan upang sumulat muli ng iyong kasaysayan ng _naka-lokal_.
Gayunpaman, Minsan ikaw ang nag-push ng iyong trabaho, ito ay isang ibang kwento sa kabuuan, at ikaw ay dapat kilalanin ang na-push na trabaho bilang huli maliban kung ikaw ay merong magandang dahilan upang baguhin ito.
Sa madaling salita, ikaw ay dapat umiwas sa pag-push ng iyong tranaho hanggang ikaw ay masaya nito at handang ibahagi sa lahat sa mundo.
====

[[_git_amend]]
==== Pagbabago sa Huling Commit

Pagbabago ng iyong pinakabagong commit ay marahil nagsusulat muli ng kasaysayan na gagawin mo.
Madalas mong gustong gawin ang dalawang pangunahing mga bagay sa iyong huling commit: baguhin lang ang commit na mensahe, o baguhin ang aktwal na laman sa commit sa pamamagitan ng pag-add, pag-alis at pagbago ng mga file.

Kung ikaw ay gusto lamang magbago ng iyong huling commit na mensahe, iyan ay madali:

[source,console]
----
$ git commit --amend
----

Ang utos sa itaas ay nagkakarga ng mga nakaraang commit na mensahe sa editor na sesyon, kapag ikaw ay gumawa ng mga pagbabago sa mensahe, i-save ang mga pagbabagong iyon at lumabas.
Kapag ikaw ay nag-save at nagsara sa editor, ang editor ay nagsusulat ng isang bagong commit na naglalaman sa pinakabago na commit na mensahe at ginagawa itong iyong bagong huling commit.

Kung, sa kabilang banda, ikaw ay gusto magbago ng aktwal na _nilalaman_ sa iyong huling commit, ang proseso ay gumagana talaga sa parehong paraan -- una gumawa ng mga pagbabago na sa tingin mo ay nakalimutan, i-stage ang mga pagbabagong iyon, at ang kasunod na `git commit --amend` _ay napapalit_ sa huling commit na iyon sa iyong bago, na pinabuting commit.

Kailangan mong maging maingat sa pamamaraang iyong dahil sa pagbago ng mga pagbabago sa SHA-1 ng commit.
Ito ay tulad ng isang maliit na rebase -- huwag baguhin ang iyong huling commit kung ikaw ay tapos na na-push ito.

[TANDAAN]
.Isang nabago na commit ay maaaring (o hindi maaaring) nangangailangan ng pagbago sa mensahe ng commit
====
Kapag iyong binago ang commit, mayroon kang pagkakataon na baguhin ang kapwa commit na mensahe at ang nilalaman sa commit.
Kung ikaw ay nagbago sa nilalaman sa commit na kalahatan, ikaw ay dapat halos tiyak sa pagbago sa commit sa mensahe upang sumasalamin sa nabago na nilalaman.

Sa kabilang banda, kung ang iyong pagbabago ay nagaangkop ng walang halaga (pag-ayos sa isang hangal na pag-type o pagdagdag ng isang file na iyong nakalimutan ma-stage) tulad ng sa mas maagang commit na mensahe ay mabuti lang, magagawa mo lang na baguhin, i-stage sila, at iwasan ang hindi kinakailangan na sesyon ng editor na ganap na may:

[source,console]
----
$ git commit --amend --no-edit
----

====

[[_changing_multiple]]
==== Pagbabago sa Maramihang Commit na mga Mensahe

Upang baguhin ang isang commit na iyon na mas malayo sa iyong kasaysayan, ikaw ay dapat lumipat sa higit na kumplikadong mga kasangkapan.
Ang Git ay walang pagbabago-kasaysayan na kasangkapan, ngunit maaari mong gamitin ang rebase na kasankapan sa mga serye ng mga commit papunta sa HEAD sila ay orihinal batay sa halip na paglipat sa kanila na para sa isa pa.
Gamit ang interactuve na rebase na kasangkapan, maaari mong itigil pagkatapos ng bawat commit na gusto mong baguhin at palitan ang mensahe, magdagdag ng mga file, o gumawa ng gusto mong gawin.
Maaari mong patakbuhin ang rebase nang interactive sa pamamagitan sa pagdagdag ng `-i` na opsyon sa `git rebase`.
Dapat mong ipahiwatig kung gaano kalayo ang gusto mong isulat muli sa mga commit sa pamamagitan sa pagsabi ng utos na kung saan ang commit ay nag-rebase nito.

Halimbawa, kung ikaw ay gustong baguhin ang huling tatlong commit na mga mensahe, o anuman sa mga commit na mensahe sa grupong iyon, punan mo yun bilang isang argumento sa `git rebase -i` at ang magulang sa huling commit na gusto mong baguhin, na kung saan ay ang `HEAD~2^` o `HEAD~3`.
Maaaring mas madali itong matandaan ang `~3` bdahil ikaw ay sinusubukang mag-edit sa huling tatlong mga commit, ngunit panataliin sa isip na ikaw ay tunay na nagtatalaga ng apat na mga commit nung nakaraan, ang magulang sa huling commit na gusto mong i-edit:

[source,console]
----
$ git rebase -i HEAD~3
----

Tandaan muli na ito ay isang rebase na utos – Sa bawat commit na kasama sa lawak ng `HEAD~3..HEAD` ay masusulatang muli, kung ikaw ay nagbago sa mensahe o hindi.
Hindi nagsasali ng anumang commit na iyong na-push na sa sentral server – paggawa nito ay malilito ang ibang mga developer sa pamamagitan ng pagbigay ng isang alternatibong bersyon sa parehong pagbabago.

Pagtatakbo nitong utos ay nagbigigay sayo ng listahan ng mga coomit sa iyong text editor na tulad nito:

[source,console]
----
pick f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file

# Rebase 710f0f8..a5f4a0d onto 710f0f8
#
# Commands:
#  p, pick = use commit
#  r, reword = use commit, but edit the commit message
#  e, edit = use commit, but stop for amending
#  s, squash = use commit, but meld into previous commit
#  f, fixup = like "squash", but discard this commit's log message
#  x, exec = run command (the rest of the line) using shell
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out
----

Ito ay importanteng tandaan na ang mga commit na ito ay nakalista sa kabaligtaran na pagkasunod-sunod kaysa sa normal na nakikita sa paggamit ng `log` na utos.
Kung ikaw ay nagpapatakno ng `log`, ikaw ay makakita ng isang bagay na tulad nito:

[source,console]
----
$ git log --pretty=format:"%h %s" HEAD~3..HEAD
a5f4a0d added cat-file
310154e updated README formatting and added blame
f7f3f6d changed my name a bit
----

Notice the reverse order.
The interactive rebase gives you a script that it’s going to run.
It will start at the commit you specify on the command line (`HEAD~3`) and replay the changes introduced in each of these commits from top to bottom.
It lists the oldest at the top, rather than the newest, because that’s the first one it will replay.

You need to edit the script so that it stops at the commit you want to edit.
To do so, change the word `pick' to the word `edit' for each of the commits you want the script to stop after.
For example, to modify only the third commit message, you change the file to look like this:

[source,console]
----
edit f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file
----

When you save and exit the editor, Git rewinds you back to the last commit in that list and drops you on the command line with the following message:

[source,console]
----
$ git rebase -i HEAD~3
Stopped at f7f3f6d... changed my name a bit
You can amend the commit now, with

       git commit --amend

Once you’re satisfied with your changes, run

       git rebase --continue
----

These instructions tell you exactly what to do.
Type

[source,console]
----
$ git commit --amend
----

Change the commit message, and exit the editor.
Then, run

[source,console]
----
$ git rebase --continue
----

This command will apply the other two commits automatically, and then you’re done.
If you change pick to edit on more lines, you can repeat these steps for each commit you change to edit.
Each time, Git will stop, let you amend the commit, and continue when you’re finished.

==== Reordering Commits

You can also use interactive rebases to reorder or remove commits entirely.
If you want to remove the ``added cat-file'' commit and change the order in which the other two commits are introduced, you can change the rebase script from this

[source,console]
----
pick f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file
----

to this:

[source,console]
----
pick 310154e updated README formatting and added blame
pick f7f3f6d changed my name a bit
----

When you save and exit the editor, Git rewinds your branch to the parent of these commits, applies `310154e` and then `f7f3f6d`, and then stops.
You effectively change the order of those commits and remove the ``added cat-file'' commit completely.

[[_squashing]]
==== Squashing Commits

It’s also possible to take a series of commits and squash them down into a single commit with the interactive rebasing tool.
The script puts helpful instructions in the rebase message:

[source,console]
----
#
# Commands:
#  p, pick = use commit
#  r, reword = use commit, but edit the commit message
#  e, edit = use commit, but stop for amending
#  s, squash = use commit, but meld into previous commit
#  f, fixup = like "squash", but discard this commit's log message
#  x, exec = run command (the rest of the line) using shell
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out
----

If, instead of ``pick'' or ``edit'', you specify ``squash'', Git applies both that change and the change directly before it and makes you merge the commit messages together.
So, if you want to make a single commit from these three commits, you make the script look like this:

[source,console]
----
pick f7f3f6d changed my name a bit
squash 310154e updated README formatting and added blame
squash a5f4a0d added cat-file
----

When you save and exit the editor, Git applies all three changes and then puts you back into the editor to merge the three commit messages:

[source,console]
----
# This is a combination of 3 commits.
# The first commit's message is:
changed my name a bit

# This is the 2nd commit message:

updated README formatting and added blame

# This is the 3rd commit message:

added cat-file
----

When you save that, you have a single commit that introduces the changes of all three previous commits.

==== Splitting a Commit

Splitting a commit undoes a commit and then partially stages and commits as many times as commits you want to end up with.
For example, suppose you want to split the middle commit of your three commits.
Instead of ``updated README formatting and added blame'', you want to split it into two commits: ``updated README formatting'' for the first, and ``added blame'' for the second.
You can do that in the `rebase -i` script by changing the instruction on the commit you want to split to ``edit'':

[source,console]
----
pick f7f3f6d changed my name a bit
edit 310154e updated README formatting and added blame
pick a5f4a0d added cat-file
----

Then, when the script drops you to the command line, you reset that commit, take the changes that have been reset, and create multiple commits out of them.
When you save and exit the editor, Git rewinds to the parent of the first commit in your list, applies the first commit (`f7f3f6d`), applies the second (`310154e`), and drops you to the console.
There, you can do a mixed reset of that commit with `git reset HEAD^`, which effectively undoes that commit and leaves the modified files unstaged.
Now you can stage and commit files until you have several commits, and run `git rebase --continue` when you’re done:

[source,console]
----
$ git reset HEAD^
$ git add README
$ git commit -m 'updated README formatting'
$ git add lib/simplegit.rb
$ git commit -m 'added blame'
$ git rebase --continue
----

Git applies the last commit (`a5f4a0d`) in the script, and your history looks like this:

[source,console]
----
$ git log -4 --pretty=format:"%h %s"
1c002dd added cat-file
9b29157 added blame
35cfb2b updated README formatting
f3cc40e changed my name a bit
----

Once again, this changes the SHA-1s of all the commits in your list, so make sure no commit shows up in that list that you’ve already pushed to a shared repository.

==== The Nuclear Option: filter-branch

There is another history-rewriting option that you can use if you need to rewrite a larger number of commits in some scriptable way – for instance, changing your email address globally or removing a file from every commit.
The command is `filter-branch`, and it can rewrite huge swaths of your history, so you probably shouldn’t use it unless your project isn’t yet public and other people haven’t based work off the commits you’re about to rewrite.
However, it can be very useful.
You’ll learn a few of the common uses so you can get an idea of some of the things it’s capable of.

[[_removing_file_every_commit]]
===== Removing a File from Every Commit

This occurs fairly commonly.
Someone accidentally commits a huge binary file with a thoughtless `git add .`, and you want to remove it everywhere.
Perhaps you accidentally committed a file that contained a password, and you want to make your project open source.
`filter-branch` is the tool you probably want to use to scrub your entire history.
To remove a file named `passwords.txt` from your entire history, you can use the `--tree-filter` option to `filter-branch`:

[source,console]
----
$ git filter-branch --tree-filter 'rm -f passwords.txt' HEAD
Rewrite 6b9b3cf04e7c5686a9cb838c3f36a8cb6a0fc2bd (21/21)
Ref 'refs/heads/master' was rewritten
----

The `--tree-filter` option runs the specified command after each checkout of the project and then recommits the results.
In this case, you remove a file called `passwords.txt` from every snapshot, whether it exists or not.
If you want to remove all accidentally committed editor backup files, you can run something like `git filter-branch --tree-filter 'rm -f *~' HEAD`.

You’ll be able to watch Git rewriting trees and commits and then move the branch pointer at the end.
It’s generally a good idea to do this in a testing branch and then hard-reset your master branch after you’ve determined the outcome is what you really want.
To run `filter-branch` on all your branches, you can pass `--all` to the command.

===== Making a Subdirectory the New Root

Suppose you’ve done an import from another source control system and have subdirectories that make no sense (`trunk`, `tags`, and so on).
If you want to make the `trunk` subdirectory be the new project root for every commit, `filter-branch` can help you do that, too:

[source,console]
----
$ git filter-branch --subdirectory-filter trunk HEAD
Rewrite 856f0bf61e41a27326cdae8f09fe708d679f596f (12/12)
Ref 'refs/heads/master' was rewritten
----

Now your new project root is what was in the `trunk` subdirectory each time.
Git will also automatically remove commits that did not affect the subdirectory.

===== Changing Email Addresses Globally

Another common case is that you forgot to run `git config` to set your name and email address before you started working, or perhaps you want to open-source a project at work and change all your work email addresses to your personal address.
In any case, you can change email addresses in multiple commits in a batch with `filter-branch` as well.
You need to be careful to change only the email addresses that are yours, so you use `--commit-filter`:

[source,console]
----
$ git filter-branch --commit-filter '
        if [ "$GIT_AUTHOR_EMAIL" = "schacon@localhost" ];
        then
                GIT_AUTHOR_NAME="Scott Chacon";
                GIT_AUTHOR_EMAIL="schacon@example.com";
                git commit-tree "$@";
        else
                git commit-tree "$@";
        fi' HEAD
----

This goes through and rewrites every commit to have your new address.
Because commits contain the SHA-1 values of their parents, this command changes every commit SHA-1 in your history, not just those that have the matching email address.
