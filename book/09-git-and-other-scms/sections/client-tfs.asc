==== Git and TFS

(((Interoperation with other VCSs, TFS)))
(((TFS)))((("TFVC", see="TFS")))
Git is becoming popular with Windows developers, and if you're writing code on Windows, there's a good chance you're using Microsoft's Team Foundation Server (TFS).
TFS is a collaboration suite that includes defect and work-item tracking, process support for Scrum and others, code review, and version control.
There's a bit of confusion ahead: *TFS* is the server, which supports controlling source code using both Git and their own custom VCS, which they've dubbed *TFVC* (Team Foundation Version Control).
Git support is a somewhat new feature for TFS (shipping with the 2013 version), so all of the tools that predate that refer to the version-control portion as ``TFS'', even though they're mostly working with TFVC.

If you find yourself on a team that's using TFVC but you'd rather use Git as your version-control client, there's a project for you.

===== Which Tool

(((git-tf)))(((git-tfs)))
In fact, there are two: git-tf and git-tfs.

Git-tfs (found at https://github.com/git-tfs/git-tfs[]) is a .NET project, and (as of this writing) it only runs on Windows.
To work with Git repositories, it uses the .NET bindings for libgit2, a library-oriented implementation of Git which is highly performant and allows a lot of flexibility with the guts of a Git repository.
Libgit2 is not a complete implementation of Git, so to cover the difference git-tfs will actually call the command-line Git client for some operations, so there are no artificial limits on what it can do with Git repositories.
Its support of TFVC features is very mature, since it uses the Visual Studio assemblies for operations with servers.
This does mean you'll need access to those assemblies, which means you need to install a recent version of Visual Studio (any edition since version 2010, including Express since version 2012), or the Visual Studio SDK.

Git-tf (whose home is at https://gittf.codeplex.com[]) is a Java project, and as such runs on any computer with a Java runtime environment.
It interfaces with Git repositories through JGit (a JVM implementation of Git), which means it has virtually no limitations in terms of Git functions.
However, its support for TFVC is limited as compared to git-tfs – it does not support branches, for instance.

So each tool has pros and cons, and there are plenty of situations that favor one over the other.
We'll cover the basic usage of both of them in this book.

[NOTE]
====
You'll need access to a TFVC-based repository to follow along with these instructions.
These aren't as plentiful in the wild as Git or Subversion repositories, so you may need to create one of your own.
Codeplex (https://www.codeplex.com[]) or Visual Studio Online (http://www.visualstudio.com[]) are both good choices for this.
====


===== Getting Started: `git-tf`

The first thing you do, just as with any Git project, is clone.
Here's what that looks like with `git-tf`:

[source,console]
----
$ git tf clone https://tfs.codeplex.com:443/tfs/TFS13 $/myproject/Main project_git
----

The first argument is the URL of a TFVC collection, the second is of the form `$/project/branch`, and the third is the path to the local Git repository that is to be created (this last one is optional).
Git-tf can only work with one branch at a time; if you want to make checkins on a different TFVC branch, you'll have to make a new clone from that branch.

This creates a fully functional Git repository:

[source,console]
----
$ cd project_git
$ git log --all --oneline --decorate
512e75a (HEAD, tag: TFS_C35190, origin_tfs/tfs, master) Checkin message
----

This is called a _shallow_ clone, meaning that only the latest changeset has been downloaded.
TFVC isn't designed for each client to have a full copy of the history, so git-tf defaults to only getting the latest version, which is much faster.

If you have some time, it's probably worth it to clone the entire project history, using the `--deep` option:

[source,console]
----
$ git tf clone https://tfs.codeplex.com:443/tfs/TFS13 $/myproject/Main \
  project_git --deep
Username: domain\user
Password:
Connecting to TFS...
Cloning $/myproject into /tmp/project_git: 100%, done.
Cloned 4 changesets. Cloned last changeset 35190 as d44b17a
$ cd project_git
$ git log --all --oneline --decorate
d44b17a (HEAD, tag: TFS_C35190, origin_tfs/tfs, master) Goodbye
126aa7b (tag: TFS_C35189)
8f77431 (tag: TFS_C35178) FIRST
0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the \
        Team Project Creation Wizard
----

Notice the tags with names like `TFS_C35189`; this is a feature that helps you know which Git commits are associated with TFVC changesets.
This is a nice way to represent it, since you can see with a simple log command which of your commits is associated with a snapshot that also exists in TFVC.
They aren't necessary (and in fact you can turn them off with `git config git-tf.tag false`) – git-tf keeps the real commit-changeset mappings in the `.git/git-tf` file.


===== Getting Started: `git-tfs`

Git-tfs cloning behaves a bit differently.
Observe:

[source,powershell]
----
PS> git tfs clone --with-branches \
    https://username.visualstudio.com/DefaultCollection \
    $/project/Trunk project_git
Initialized empty Git repository in C:/Users/ben/project_git/.git/
C15 = b75da1aba1ffb359d00e85c52acb261e4586b0c9
C16 = c403405f4989d73a2c3c119e79021cb2104ce44a
Tfs branches found:
- $/tfvc-test/featureA
The name of the local branch will be : featureA
C17 = d202b53f67bde32171d5078968c644e562f1c439
C18 = 44cd729d8df868a8be20438fdeeefb961958b674
----

Notice the `--with-branches` flag.
Git-tfs is capable of mapping TFVC branches to Git branches, and this flag tells it to set up a local Git branch for every TFVC branch.
This is highly recommended if you've ever branched or merged in TFS, but it won't work with a server older than TFS 2010 – before that release, ``branches'' were just folders, so git-tfs can't tell them from regular folders.

Let's take a look at the resulting Git repository:

[source,powershell]
----
PS> git log --oneline --graph --decorate --all
* 44cd729 (tfs/featureA, featureA) Goodbye
* d202b53 Branched from $/tfvc-test/Trunk
* c403405 (HEAD, tfs/default, master) Hello
* b75da1a New project
PS> git log -1
commit c403405f4989d73a2c3c119e79021cb2104ce44a
Author: Ben Straub <ben@straub.cc>
Date:   Fri Aug 1 03:41:59 2014 +0000

    Hello

    git-tfs-id: [https://username.visualstudio.com/DefaultCollection]$/myproject/Trunk;C16
----

There are two local branches, `master` and `featureA`, which represent the initial starting point of the clone (`Trunk` in TFVC) and a child branch (`featureA` in TFVC).
You can also see that the `tfs` ``remote'' has a couple of refs too: `default` and `featureA`, which represent TFVC branches.
Git-tfs maps the branch you cloned from to `tfs/default`, and others get their own names.

Another thing to notice is the `git-tfs-id:` lines in the commit messages.
Instead of tags, git-tfs uses these markers to relate TFVC changesets to Git commits.
This has the implication that your Git commits will have a different SHA-1 hash before and after they have been pushed to TFVC.

===== Git-tf[s] Workflow

[NOTE]
====
Regardless of which tool you're using, you should set a couple of Git configuration values to avoid running into issues.

[source,console]
----
$ git config set --local core.ignorecase=true
$ git config set --local core.autocrlf=false
----
====

The obvious next thing you're going to want to do is work on the project.
TFVC and TFS have several features that may add complexity to your workflow:

. Feature branches that aren't represented in TFVC add a bit of complexity.
  This has to do with the *very* different ways that TFVC and Git represent branches.
. Be aware that TFVC allows users to ``checkout'' files from the server, locking them so nobody else can edit them.
  This obviously won't stop you from editing them in your local repository, but it could get in the way when it comes time to push your changes up to the TFVC server.
. TFS has the concept of ``gated'' checkins, where a TFS build-test cycle has to complete successfully before the checkin is allowed.
  This uses the ``shelve'' function in TFVC, which we don't cover in detail here.
    You can fake this in a manual fashion with git-tf, and git-tfs provides the `checkintool` command which is gate-aware.

In the interest of brevity, what we'll cover here is the happy path, which sidesteps or avoids most of these issues.

===== Workflow: `git-tf`


Let's say you've done some work, made a couple of Git commits on `master`, and you're ready to share your progress on the TFVC server.
Here's our Git repository:

[source,console]
----
$ git log --oneline --graph --decorate --all
* 4178a82 (HEAD, master) update code
* 9df2ae3 update readme
* d44b17a (tag: TFS_C35190, origin_tfs/tfs) Goodbye
* 126aa7b (tag: TFS_C35189)
* 8f77431 (tag: TFS_C35178) FIRST
* 0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the \
          Team Project Creation Wizard
----

We want to take the snapshot that's in the `4178a82` commit and push it up to the TFVC server.
First things first: let's see if any of our teammates did anything since we last connected:

[source,console]
----
$ git tf fetch
Username: domain\user
Password:
Connecting to TFS...
Fetching $/myproject at latest changeset: 100%, done.
Downloaded changeset 35320 as commit 8ef06a8. Updated FETCH_HEAD.
$ git log --oneline --graph --decorate --all
* 8ef06a8 (tag: TFS_C35320, origin_tfs/tfs) just some text
| * 4178a82 (HEAD, master) update code
| * 9df2ae3 update readme
|/
* d44b17a (tag: TFS_C35190) Goodbye
* 126aa7b (tag: TFS_C35189)
* 8f77431 (tag: TFS_C35178) FIRST
* 0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the \
          Team Project Creation Wizard
----

Mukhang may ibang nagtatrabaho, rin, at ngayon mayroon na tayong magkakaibang kasaysayan.
Ito ay kung saan kumikinang ang Git, ngunit mayroon tayong dalawang pagpipilian kung paano magpatuloy:

. Ang paggawa ng isang merge na commit ay nagdaramdam na natural bilang isang user ng Git (kahit na, iyon ay ang kung ano ang ginagawa ng `git pull`), at ang git-tf ay maaaring gawin ito para sa iyo gamit ang isang simpleng `git tf pull`.
  Magbigay alam, gayunpaman, na ang TFVC ay hindi nag-iisip sa ganitong paraan, at kung ikaw ay magpu-push ng merge na mga commit ang iyong kasaysayan ay magsisimulang magmukhang kakaiba sa parehong banda, na maaaring nakakalito.
  Gayunpaman, kung plinano mong magsumite ng lahat ng iyong mga pagbabago bilang isang hanay ng pagbabago, ito na yata ang pinakamadaling mapagpipilian.
. Ang pag-rebase ay ginagawang linear ang ating kasaysayan ng commit, na nangangahulugang mayroon tayong opsyon ng pagpapalit sa bawat isa sa ating Git na mga commit sa isang TFVC na hanay ng pagbabago.
  Dahil iniiwanan nitong bukas ang karamihan sa mga opsyon, inirerekomenda namin na gawin mo ito sa ganitong paraan; ang git-tf ay ginagawang madali ito para sa iyo gamit ang `git tf pull --rebase`.

Ang pagpili ay nasa iyo.
Para sa halimbawang ito, iri-rebase natin ang:
For this example, we'll be rebasing:

[source,console]
----
$ git rebase FETCH_HEAD
First, rewinding head to replay your work on top of it...
Applying: update readme
Applying: update code
$ git log --oneline --graph --decorate --all
* 5a0e25e (HEAD, master) update code
* 6eb3eb5 update readme
* 8ef06a8 (tag: TFS_C35320, origin_tfs/tfs) just some text
* d44b17a (tag: TFS_C35190) Goodbye
* 126aa7b (tag: TFS_C35189)
* 8f77431 (tag: TFS_C35178) FIRST
* 0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the \
          Team Project Creation Wizard
----

Ngayon handa na tayong gumawa ng isang checkin sa TFVC na server.
Ang git-tf ay nagbibigay sa iyo ng pagpipilian sa paggawa ng isang solong hanay ng pagbabago na nagrerepresenta ng lahat ng mga pagbabago mula nung huli (`--shallow`, na ang default) at gumagawa ng isang panibagong hanay ng pagbabago para sa bawat Git na commit (`--deep`).
Para sa halimbawang ito, gagawa lang tayo ng isang hanay ng pagbabago:

[source,console]
----
$ git tf checkin -m 'Updating readme and code'
Username: domain\user
Password:
Connecting to TFS...
Checking in to $/myproject: 100%, done.
Checked commit 5a0e25e in as changeset 35348
$ git log --oneline --graph --decorate --all
* 5a0e25e (HEAD, tag: TFS_C35348, origin_tfs/tfs, master) update code
* 6eb3eb5 update readme
* 8ef06a8 (tag: TFS_C35320) just some text
* d44b17a (tag: TFS_C35190) Goodbye
* 126aa7b (tag: TFS_C35189)
* 8f77431 (tag: TFS_C35178) FIRST
* 0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the \
          Team Project Creation Wizard
----

Mayroong isang bagong `TFS_C35348` na tag, na nagpapakita na ang TFVC ay nag-iimbak ng eksaktong magkaparehong snapshot sa `5a0e25e` na commit.
Importanteng tandaan na hindi bawat Git na commit ay nangangailangang magkaroon ng eksaktong kopya sa TFVC; ang `6eb3eb5` na commit, halimbawa, ay hindi umiiral saanman sa server.

Ito ay ang pangunahing daloy ng trabaho.
Mayroong iilang ibang konsiderasyon na gugustuhin mong isaisip:

* Walang pag-branch.
  Ang Git-tf ay maaari lamang gumawa ng mga repositoryo ng Git mula sa isang TFVC na branch sa isang pagkakataon.
* Pagtulong gamit ang alinman sa TFVC o Git, ngunit hindi ang dalawa.
  Magkaibang git-tf ay magko-clone ng parehong TFVC na repositoryo ay maaaring magkaroon ng magkaibang commit na SHA-1 na mga hash, na magsasanhi ng walang hanggang sakit sa ulo.
* Kung ang daloy ng trabaho ng iyong koponan ay naglalaman ng pagtutulungan sa Git at pana-panahong nagsi-sync sa TFVC, upang komunekta lamang sa TFVC kasama ang isa sa mga repositoryo ng Git.

===== Daloy ng trabaho: `git-tfs`

Maglakad tayo sa parehong senaryo sa paggamit ng git-tfs.
Narito ang bagong mga commit na ginawa natin sa `master` na branch sa ating Git na repositoryo:

[source,powershell]
----
PS> git log --oneline --graph --all --decorate
* c3bd3ae (HEAD, master) update code
* d85e5a2 update readme
| * 44cd729 (tfs/featureA, featureA) Goodbye
| * d202b53 Branched from $/tfvc-test/Trunk
|/
* c403405 (tfs/default) Hello
* b75da1a New project
----

Ngayon tingnan natin kung may ibang tao na nakagawa ng trabaho habang tayo nagha-hack sa malayo:

[source,powershell]
----
PS> git tfs fetch
C19 = aea74a0313de0a391940c999e51c5c15c381d91d
PS> git log --all --oneline --graph --decorate
* aea74a0 (tfs/default) update documentation
| * c3bd3ae (HEAD, master) update code
| * d85e5a2 update readme
|/
| * 44cd729 (tfs/featureA, featureA) Goodbye
| * d202b53 Branched from $/tfvc-test/Trunk
|/
* c403405 Hello
* b75da1a New project
----

Oo, lumalabas na ang ating kasama sa trabaho ay nagdagdag ng isang bagong TFVC na hanay ng pagbabago, na magpapakita bilang bagong `aea74a0` na commit, at ang `tfs/default` na remote na branch ay lumipat.

Tulad ng git-tf, mayroon tayong dalawang pangunahing mga opsyon para sa kung paano lutasin itong magkakaibang kasaysayan:

. Mag-rebase upang mapreserba ang linear na kasaysayan.
. Mag-merge upang mapreserba ang kung ano talaga ang nangyari.

Sa kasong ito, tayo ay gagawa ng isang ``malalim'' na checkin, kung saan ang bawat Git na commit ay magiging isang TFVC na hanay ng pagbabago, kaya gusto nating mag-rebase.

[source,powershell]
----
PS> git rebase tfs/default
First, rewinding head to replay your work on top of it...
Applying: update readme
Applying: update code
PS> git log --all --oneline --graph --decorate
* 10a75ac (HEAD, master) update code
* 5cec4ab update readme
* aea74a0 (tfs/default) update documentation
| * 44cd729 (tfs/featureA, featureA) Goodbye
| * d202b53 Branched from $/tfvc-test/Trunk
|/
* c403405 Hello
* b75da1a New project
----

Ngayon tayo ay handa nang kumpletuhin ang ating pag-ambag sa pamamagitan ng pagtsi-check in ng ating code sa TFVC na server.
Gagamitin natin ang `rcheckin` na utos dito upang lumikha ng isang TFVC na hanay ng pagbabago para sa bawat Git na commit sa landas mula sa HEAD patungo sa unang `tfs` na remote na branch na natagpuan (ang `checkin` na utos ay lilikha lamang ng isang hanay ng pagbabago, tulad ng pagpipi ng Git na mga commit).

[source,powershell]
----
PS> git tfs rcheckin
Working with tfs remote: default
Fetching changes from TFS to minimize possibility of late conflict...
Starting checkin of 5cec4ab4 'update readme'
 add README.md
C20 = 71a5ddce274c19f8fdc322b4f165d93d89121017
Done with 5cec4ab4b213c354341f66c80cd650ab98dcf1ed, rebasing tail onto new TFS-commit...
Rebase done successfully.
Starting checkin of b1bf0f99 'update code'
 edit .git\tfs\default\workspace\ConsoleApplication1/ConsoleApplication1/Program.cs
C21 = ff04e7c35dfbe6a8f94e782bf5e0031cee8d103b
Done with b1bf0f9977b2d48bad611ed4a03d3738df05ea5d, rebasing tail onto new TFS-commit...
Rebase done successfully.
No more to rcheckin.
PS> git log --all --oneline --graph --decorate
* ff04e7c (HEAD, tfs/default, master) update code
* 71a5ddc update readme
* aea74a0 update documentation
| * 44cd729 (tfs/featureA, featureA) Goodbye
| * d202b53 Branched from $/tfvc-test/Trunk
|/
* c403405 Hello
* b75da1a New project
----

Pansinin kung paano pagkatapos ng bawat matagumpay na checkin sa TFVC na server, ang git-tfs ay nagre-rebase ng natitirang trabaho sa kung ano ang ginawa nito.
Iyon ay dahil nagdaragdag ito ng `git-tfs-id` na field sa ilalim ng commit na mga mensahe, na nagbabago sa SHA-1 na mga hash.
Ito ay eksaktong batay sa pagkakadisenyo, at walang dapat ipangamba, ngunit dapat mong bigyang alam na ito ay nangayayri, lalo na kung ikaw ay namamahagi ng mga Git na commit sa iba.

Ang TFS ay may maraming mga tampok na sumasama sa sistema na version control nito, katulad ng mga item ng trabaho, itinalagang mga taga-review, naka-gate na mga checkin, at iba pa.
Maaaring masalimuot na magtrabaho sa mga tampok na ito gamit lamang ang isang command-line na kasangkapan, ngunit sa kabutihang palad ang git-tfs ay hahayaan kang maglunsad ng isang grapikal na checkin na kasangkapan nang sobrang dali:

[source,powershell]
----
PS> git tfs checkintool
PS> git tfs ct
----

Nagmumukha itong medyo ganito:

.The git-tfs checkin tool.
image::images/git-tfs-ct.png[The git-tfs checkin tool.]

Ito ay magmumukhang pamilyar sa mga gumagamit ng TFS, dahil ito ay magkapareho ng diyalogo sa nailunsad mula sa loob ng Visual Studio.

Ang Git-tfs din ay hahayaang kang mag-kontrol ng TFVC na mga branch mula sa iyong Git na repositoryo.
Bilang isang halimbawa, gumawa tayo ng isa:

[source,powershell]
----
PS> git tfs branch $/tfvc-test/featureBee
The name of the local branch will be : featureBee
C26 = 1d54865c397608c004a2cadce7296f5edc22a7e5
PS> git log --oneline --graph --decorate --all
* 1d54865 (tfs/featureBee) Creation branch $/myproject/featureBee
* ff04e7c (HEAD, tfs/default, master) update code
* 71a5ddc update readme
* aea74a0 update documentation
| * 44cd729 (tfs/featureA, featureA) Goodbye
| * d202b53 Branched from $/tfvc-test/Trunk
|/
* c403405 Hello
* b75da1a New project
----

Ang paggawa ng isang branch sa TFVC ay nangangahulungan sa pagdaragdag ng isang hanay ng pagbabago kung saan ang branch na iyon ay umiiral na ngayon, at ito ay nakapanukala bilang isang Git na commmit.
Tandaan din na ang git-tfs ay *gumawa* ng `tfs/featureBee` na remote na branch, ngunit ang `HEAD` ay nakaturo pa rin sa `master`.
Kung gusto mong magtrabaho sa preskong pagkakagawa na branch, gugustuhin mong magbase ng iyong bagong mga commit sa `1d54865` na commit, marahil sa pamamagitan ng paggawa ng isang paksa na branch mula sa commit na iyon.

===== Git at TFS na Buod

Ang Git-tf at Git-tfs ay parehong dakilang mga kasangkapan para sa pag-interface na may isang TFVC na server.
Pinapayagan ka nilang lokal na gamitin ang kapangyarihan ng Git, umiwas sa patuloy na pagkakaroon ng papunta at pabalik sa sentral na TFVC na server, at gawing sobrang mas madali ang iyong buhay bilang isang developer, na hindi pinipilit ang iyong buong koponan na lumipat sa Git.
Kung ikaw ay nagtatrabaho sa Windows (na pwede kung ang iyong koponan ay gumagamit ng TFS), marahil gugustuhin mong gumamit ng git-tfs, dahil ang hanay tampok nito ay mas kumpleto, ngunit kung ikaw ay nagtatrabaho sa ibang plataporma, gagamitin mo ang git-tf, na mas limitado.
Sa kadalasang mga kasangkapan sa kabanatang ito, dapat kang pumili ng isa sa mga sistema ng version-control na ito upang maging makanoniko, at gamitin ang iba pang isa na nasa isang pantulong na anyo – alinman sa Git o TFVC ang dapat maging sentro ng kolaborasyon, hindi ang dalawa.
