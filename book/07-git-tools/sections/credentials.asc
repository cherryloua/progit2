[[_credential_caching]]
=== Credential Storage

(((credentials)))
(((git commands, credential)))
If you use the SSH transport for connecting to remotes, it's possible for you to have a key without a passphrase, which allows you to securely transfer data without typing in your username and password.
However, this isn't possible with the HTTP protocols â€“ every connection needs a username and password.
This gets even harder for systems with two-factor authentication, where the token you use for a password is randomly generated and unpronounceable.

Fortunately, Git has a credentials system that can help with this.
Git has a few options provided in the box:

* The default is not to cache at all.
  Every connection will prompt you for your username and password.
* The ``cache'' mode keeps credentials in memory for a certain period of time.
  None of the passwords are ever stored on disk, and they are purged from the cache after 15 minutes.
* The ``store'' mode saves the credentials to a plain-text file on disk, and they never expire.
  This means that until you change your password for the Git host, you won't ever have to type in your credentials again.
  The downside of this approach is that your passwords are stored in cleartext in a plain file in your home directory.
* If you're using a Mac, Git comes with an ``osxkeychain'' mode, which caches credentials in the secure keychain that's attached to your system account.
  This method stores the credentials on disk, and they never expire, but they're encrypted with the same system that stores HTTPS certificates and Safari auto-fills.
* If you're using Windows, you can install a helper called ``Git Credential Manager for Windows.''
  This is similar to the ``osxkeychain'' helper described above, but uses the Windows Credential Store to control sensitive information.
  It can be found at https://github.com/Microsoft/Git-Credential-Manager-for-Windows[].

You can choose one of these methods by setting a Git configuration value:

[source,console]
----
$ git config --global credential.helper cache
----

Marami sa mga tumutulong ay mayroong mga opsyon.
Ang ``store'' na katulong ay maaaring kumuha ng isang `--file <path>` na argumento, na kung saan ay which nagpapasadya sa kung saan ang plain-teksto na file ay naka-save (ang default ay `~/.git-credentials`).
Ang ``cache'' na katulong ay tumatanggap ng `--timeout <seconds>` na opsyon, na kung saan ay nagbabago sa halaga ng oras sa kanyang daemon ay pinanatiling tumatakbo (ang default ay ``900'', o 15 minuto).
Ito ang isang halimbawa kung paano mo siya i-configure ang ``store'' na katulong na may isang pasadyang pangalan ng file:

[source,console]
----
$ git config --global credential.helper 'store --file ~/.my-credentials'
----

Ang Git ay nagpapahintulot kahit na ikaw ay naka-configure nang maraming mga katulong.
Kapag naghahanap ng mga credential para sa isang partikular na host, Ang Git ay magtanong sa kanila sa pagkasunod-sunod, at ihinto pagkatapos ang unang sagot ay ibinigay.
Kapag nag-save sa mga credential, Ang Git ay nagpapadala ng username at password sa *lahat* ng mga katulong na nasa listahan, at sila ay maaaring pumili kung ano ang gagawin nila.
Narito kung ano ang isang `.gitconfig` na itsura kung ikaw ay mayroong isang credential na file sa isang thumb drive, pero gustong gumagamit ng in-memory cache upang i-save ang ilang mga typing kung ang drive ay hindi nakapasok:

[source,ini]
----
[credential]
    helper = store --file /mnt/thumbdrive/.git-credentials
    helper = cache --timeout 30000
----

==== Sa ilalim ng Hood

Paano ang lahat ng ito ay gumagana?
Ang root na utos ng Git para sa credential-katulong na sistema ay `git credential`, na kung saan ay kumukuha ng utos bilang isang argumento, at pagkatapos maramign input sa pamamagitan ng stdin.

Maaaring mas madali ito na maunawaan na may isang halimbawa.
Sabihin natin na ang isang crendential na katulong ay na-configure na, at ang katulong ay naka-imbak ng mga credential para sa `mygithost`.
Ito ang sesyon na gumagamit ng ``fill'' na utos, na kung saan ay tumatawag kapag ang Git ay sumusubok na tingnan ang mga credential para sa isang host:

[source,console]
----
$ git credential fill <1>
protocol=https <2>
host=mygithost
<3>
protocol=https <4>
host=mygithost
username=bob
password=s3cre7
$ git credential fill <5>
protocol=https
host=unknownhost

Username for 'https://unknownhost': bob
Password for 'https://bob@unknownhost':
protocol=https
host=unknownhost
username=bob
password=s3cre7
----

<1> Ito ay ang command line na nagpapasimula sa pakikipag-ugnayan.
<2> Ang Git-credential ay naghihintay para sa input sa stdin.
    Kami ay nagbibigay nito na may bagay na alam namin: ang protocol at hostname.
<3> Isang blangko linya na nagpapahiwatig na ang input ay kumpleto, at ang credential na sistema ay dapat sagutin na kung ano ang alam.
<4> Ang Git-credential pagkatapos pumalit, at sumusulat sa stdout na may mga bit ng impormasyon na nakita.
<5> Kung ang mga credential ay hindi matagpuan, Ang Git ay nagtatanong sa gumagamit para sa username at password, at nagbibigay sa kanila pabalik sa hinihinging stdout (narito sila naka-attach sa parehong console).

Ang credential na sistema ay aktwal na tumatawag sa program na naghihiwalay mula sa Git mismo; kung alin at kung papaano depende sa `credential.helper` na halaga ng configuration.
Mayroong maraming mga form na maaaring kumuha:

[options="header"]
|======
| Configuration Value | Behavior
| `foo` | Runs `git-credential-foo`
| `foo -a --opt=bcd` | Runs `git-credential-foo -a --opt=bcd`
| `/absolute/path/foo -xyz` | Runs `/absolute/path/foo -xyz`
| `!f() { echo "password=s3cre7"; }; f` | Code after `!` evaluated in shell
|======

Kaya ang mga tumutulong na nilalarawan sa itaas ay aktwal na nagngangalang `git-credential-cache`, `git-credential-store`, at iba pa, at maaari kang maka-configure nila na kumuha ng command-line na mga argumento.
Ang general form para dito ay ``git-credential-foo [args] <action>.''
Ang stdin/stdout na protocol ay pareho lang sa git-credential, pero sila ay ginagamit ng bahagyang ibang grupo ng mga aksyon:

* ang `get` ay isang hiling para sa username/password na pares.
* ang `store` ay isang hiling para i-save ang grupo ng mga credential sa sa memoria ng katulong na ito.
* ang `erase` ay naglinis ng mga credential para sa binigay na mga property mula sa memoria ng katulong na ito.

Para sa `store` at `erase` na mga aksyon, walang sagot ang kinakailangan (Hindi pa rin pinapansin ng Gitpa).
Para sa `get` na aksyon, gayunpaman, ang Git ay isang napaka interesado na kung ano ang sinasabi ng katulong.
Kung ang katulong ay walang anumang alam na magagamit, magagawa itong i-exit na walang output, pero hindi ito alam, dapat dagdagan ang ibinigay na impormasyon na may impormasyon na naka-imbak dito.
Ang output ay ginagawang mga serye ng mga assignment na mga pahayag; anumang ibinigay ay papalitan kung ano ang alam na ni Git.

Narito ang parehong halimbawa mula sa itaas, ngunit laktawan ang git-credential at pupuntang tuwid para sa git-credential-store:

[source,console]
----
$ git credential-store --file ~/git.store store <1>
protocol=https
host=mygithost
username=bob
password=s3cre7
$ git credential-store --file ~/git.store get <2>
protocol=https
host=mygithost

username=bob <3>
password=s3cre7
----

<1> Narito ang aming sasabihin na `git-credential-store` ay mag-save ng maraming mga credential: ang username na ``bob'' at ang password ``s3cre7'' ay gagamitin kapag ang `https://mygithost` ay pinapasok.
<2> Ngayon ay nakuha na namin ang mga credential na iyon.
    Nagbibigay kami ng mga bahagi sa koneksyon na alam na namin (`https://mygithost`), at ang walang laman na linya.
<3> `git-credential-store` ay sumasagot na may username at password na ipinasok namin sa itaas.

Narito kung ano ang  `~/git.store` na file na nagmumukha:

[source,ini]
----
https://bob:s3cre7@mygithost
----

Ito ay isang mga serye ng mga linya lamang, bawat isa ay naglalaman ng crendetial-decorated na UTL.
Ang `osxkeychain` at `wincred` na mga katulong ay gumgamit ng katutubong format sa kanilang backing na mga tindahan, habang ang `cache` ay gumagamit ng sariling in-memory na format (na walang ibang proseso na maaaring magbasa).

==== Ang Pasadyang Credential na Cache

Kung ganoon ang `git-credential-store` at mga kaibigan ay naghihiwalay ng mga programa sa Git, ito ay hindi gaanong isang paglundag na napagtanto na ang _anumang_ programa ay maaaring isang Git crendetial na katulong.
Ang mga katulong ay nagbibigay ng Git na nagtatalakay ng maraming karaniwang gumagamit ng mga kaso, pero hindi lahat.
Halimbawa, sabihin natin na ang iyong koponan ay maraming mga credential na ibinahagi sa buong koponan, marahil para sa deployment.
Ang mga na-imbak na isang ibinahagi na direktoryo, ngunit ayaw mong ikopya sa iyong sariling tindahan ng credential, dahil madalas silang nagbabago nito.
Wala sa mga umiiral na mga katulong ang sumasakop sa kasong ito; tingnan natin kung ano ito at kakailanganin na isulat ang sarili.
There are several key features this program needs to have:

. Ang tanging aksyon na kailangan natin bigyang pansin ay ang `get`; `store` at `erase` ay sumusulat na mga operasyon, kaya lalabas lang tayo ng malinos kapag sila ay nakatanggap.
. Ang file format sa ibinahagi-credential na file ay pareho na ginagamit ng `git-credential-store`.
. Ang lokasyon sa file na iyon ay medyo karaniwan, pero dapat nating pahintulutan na ang gumagamit ay makapasa ng isang pasadyang path kung sakali.

Muli, magsusulat tayo ng extensyon ng Ruby na ito, ngunit ang anumang wika ay gagana hangga't maipatutupad ng Git ang maaaring magsagawa ng natapos na produkto.
Narito ang buong source code sa ating bagong credential na katulong:

[source,ruby]
--------
include::../git-credential-read-only[]
--------

<1> Dito namin mai-parse ang command-line na mga opsyon, pumapayag sa gumagamit na magtakda ng input file. Ang default ay `~/.git-credentials`.
<2> Ang programa ay tumutugon lamang kung ang aksyon ay `get` at ang backing-store na file ay umiiral.
<3> Itomg loop ay nagbabasa mula sa stdin hanggang ang unang blangkong linya ay naabot.
    Ang mga input ay na-imbak sa `known` na hash para sa reperensiya mamaya.
<4> Ang loop ay nagbabasa ng nilalaman sa imbakan ng file, naghahanap ng mga tumutugma.
    Kung ang protocol at host mula sa `known` na tugma sa linyang ito, ang programa ay nag-print ng mga resulta sa stdout at umiiral.

I-save namin ang aming mga katulong bilang `git-credential-read-only`, ilagay ito sa isang lugar sa aming `PATH` at markahan itong executable.
Narito ang kung ano ang interactive na sesyon na nagmumukha:

[source,console]
----
$ git credential-read-only --file=/mnt/shared/creds get
protocol=https
host=mygithost

protocol=https
host=mygithost
username=bob
password=s3cre7
----

Dahil sa pangalang ito na nagsisimula ng ``git-'', maaari nating gamitin ang simpleng syntax para sa halaga ng pagsasaayos:

[source,console]
----
$ git config --global credential.helper 'read-only --file /mnt/shared/creds'
----

Tulad ng iyong nakikita, pag-extend ng sistemang ito ay medyo tapat, at maaaring maglutas ng ilang karaniwang mga problema para sa iyo at sa iyong koponan
