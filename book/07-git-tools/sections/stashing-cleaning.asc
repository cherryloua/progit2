[[_git_stashing]]
=== Pag-stash at Paglilinis

Kadalasan, kapag nagtatrabaho ka sa bahagi ng iyong proyekto, ang mga bagay ay nasa isang kalat na estado at gusto mong lumipat ng mga branch para sa isang kaunting trabaho upang magtrabaho sa ibang bagay.
Ang problema ay, hindi mo gustong gumawa ng isang commit sa kalahating natapos na trabaho para lamang makuha mong bumalik sa punto ito mamaya.
Ang sagot sa isyung ito ay ang utos na `git stash`.

Kumukuha ang pag-stash ng maruming estado ng iyong gumaganang direktoryo -- iyon ay, ang iyong binagong sinusubaybayan na mga file at mga naka-stage na mga pagbabago -- at i-save ito sa isang stack ng mga hindi natapos ng mga pagbabago na maaari mong muling ilapat sa anumang oras (kahit na sa ibang branch).

[TANDAAN]
.Paglilipat sa `git stash push`
====
Sa huling Oktubre 2017, nagkaroon ng malawak na talakayan sa listahan ng pag-mail ng Git, kung saan ang utos na `git stash save` ay hindi na magagamit na pabor sa umiiral na alternatibong `git stash push`.
Ang pangunahing dahilan para rito ay ang `git stash push` ay nagpapakilala ng opsyon sa pag-stash ng napiling _pathspecs_, isang bagay na hindi suportado ng `git stash save`.

Ang `git stash save` ay hindi aalis sa anumang oras sa lalong madaling panahon, kaya huwag mag-alala tungkol dito na biglang mawawala.
Ngunit maaaring gusto mong simulan ang paglipat sa alternibo na `push` para sa bagong pag-andar.
====

==== Pag-stash ng Iyong Trabaho

Upang ipakita ang pag-stash, pupunta ka sa iyong proyekto at simulan ang pagtatrabaho sa isang iilang mga file at posibleng i-stage ang isa sa mga pagbabago.
Kung papatakbuhin mo ang `git status`, makikita mo ang iyong maruming estado:

[source,console]
----
$ git status
Ang mga pagbabagong dapat i-commit:
  (gumamit ng "git reset HEAD <file>..." upang mag-unstage)

	nabago:   index.html

Mga pagbabago na hindi na-stage para sa commit:
  (gumamit ng "git add <file>..." upang ma-update kung ano ang iko-commit)
  (gumamit ng "git checkout -- <file>..." upang iwaksi ang mga pagbababago sa iyong tinatrabahong direktoryo)

	nabago:   lib/simplegit.rb
----

Ngayon nais mong magpalit ng mga branch, ngunit hindi mo pa gusto na i-commit kung ano ang iyong tinatrabaho; kaya i-stash mo ang iyong mga pagbabago.
Para mag-push ng isang bagong stash sa iyong stack, patakbuhin ang `git stash` o `git stash save`: 

[source,console]
----
$ git stash
Naka-save na gumaganang direktoryo at estado ng indeks \
  "WIP sa master: 049d078 idinagdag ang indeks na file"
Ang HEAD ngayon ay nasa 049d078 na nagdagdag sa indeks na file
(Upang maibalik ang mga ito, magtipa ng "git stash apply")
----

Maaari mo ng makita na ang iyong gumaganang direktoryo ay malinis:

[source,console]
----
$ git status
# Sa branch na master
walang mai-commit, malinis ang gumaganang direktoryo
----

Sa puntong ito, maaari kang magpalit ng mga branch at magtrabaho sa ibang lugar; ang iyong mga pagbabago ay naka-imbak sa iyong stack
Upang makita kung anong mga stash na iyong inimbak, maaari kang gumamit ng `git stash list`:

[source,console]
----
$ git stash list
stash@{0}: WIP sa master: 049d078 idinagdag ang indeks na file
stash@{1}: WIP sa master: c264051 Ibalik ang "idinagdag ang file_size"
stash@{2}: WIP sa master: 21d80a5 idinagdag ang bilang sa log
----

Sa kasong ito, dalawang stash ang natapos sa nakaraan, kaya mayroon kang access sa tatlong iba't-ibang naka-stash na mga trabaho.
Maaari mo muling ilapat ang isa na iyong na-stash sa pamamagitan ng paggamit ng utos na ipanapakita sa output ng tulong ng orihinal na utos ng stash: `git stash apply`.
Kung nais mo na ilapat ang isa sa mas lumang mga stash, maaari mong matukoy ito sa pamamagitan ng pagbibigay ng pangalan nito, tulad nito: `git stash apply stash@{2}`.
Kung hindi ka nagtukoy ng isang stash, ipinagpapalagay ng Git ang pinakabago na stash at sinusubukan na ilapat ito:

[source,console]
----
$ git stash apply
Sa branch master
Ang mga pagbabago ay hindi na-stage para sa commit:
  (gumamit ng "git add <file>..." upang ma-update kung ang mako-commit)
  (gumamit ng "git checkout -- <file>..." upang iwaksi ang mga pagbabago sa gumaganang direktoryo)

	nabago:   index.html
	nabago:   lib/simplegit.rb

walang naidagdag na mga pagbabago sa commit (gumamit ng "git add" at/o "git commit -a")
----

Maaari mong makita na ang Git ay nagbabago muli ng mga file na iyong ibinalik kapag ikaw ay nag-save ng stash.
Sa kasong ito, mayroon kang isang malinis na gumaganang direktoryo kapag sinubukan mo na mag-lapat ng stash, at sinubukan mo na ilapat ito sa parehong branch kung saan mo ito si-nave.
Ang pagkakaroon ng isang malinis na gumaganang direktoryo at paglalapat nito sa parehong branch ay hindi kinakailangan upang matagumpay na maglapat ng isang stash.
Maaari mo i-save ang isang stash sa isang branch, palitan sa ibang branch mamaya, at subukan na muling ilapat ang mga pagbabago.
Maaari mo ka ring magkaroon ng mga file na binago o hindi na-commit sa iyong gumaganang direktoryo kapag ikaw ay naglapat ng isang stash -- Binibigyan ka ng Git ng mga kasalungatan sa pag-merge kung hindi na mailalapat nang malinis.

Ang mga pagbabago sa iyong mga file ay muli ng nailapat, ngunit ang file na naka-stage noon ay hindi na muling ma-stage.
Upang gawin iyon, dapat mong patakbuhin ang utos na `git stash apply` na may isang opsyon na `--index` upang sabihan ang utos na subukan na muling ilapat ang naka-stage na mga pagbabago.
Kung sa halip ay napatakbo mo ito , naibalik ka sa iyong orihinal na posisyon:

[source,console]
----
$ git stash apply --index
Sa branch master
Ang mga pagbabago na i-commit:
  (gumamit ng "git reset HEAD <file>..." para i-unstage)

	nabago:   index.html

Ang mga pagbabago na hindi na-stage para sa commit:
  (gumamit ng "git add <file>..." upang mag-update kung ano ang mako-commit)
  (gumamit ng "git checkout -- <file>..." upang iwaksi ang mga pagbabago sa gumaganang direktoryo)

	nabago:   lib/simplegit.rb
----

Ang opsyon na apply ay sinusubukan lamang na maglapat ng naka-stash na trabaho -- ituloy mo upang magkaroon ka nito sa iyong stack.
Upang matanggal ito, maaari mong patakbuhin ang `git stash drop` na may pangalan ng stash na tatanggalin:

[source,console]
----
$ git stash list
stash@{0}: WIP on master: 049d078 added the index file
stash@{1}: WIP sa master: c264051 Ibinalik ang  "idinagdag na file_size"
stash@{2}: WIP sa master: 21d80a5 idinagdag ang bilang sa log
$ git stash drop stash@{0}
Alisin ang stash@{0} (364e91f3f268f0900bc3ee613f9f733e82aaed43)
----

Maaari mo ring patakbuhin ang `git stash pop` upang ilapat ang stash at pagkatapos ay kaagad na alisin ito mula sa iyong stack.

==== Malikhain na Pag-stash

Mayroong ilang ibang stash na maaari ring kapaki-pakinabang.
Ang unang opsyon na medyo sikat ay ang opsyon na `--keep-index` sa utos na `stash save`.
Ito ay nagsasabi sa Git na hindi lamang isali ang lahat ng naka-stage na nilalaman sa stash na nilikha, sabay na iwanan ito sa indeks.

[source,console]
----
$ git status -s
M  index.html
 M lib/simplegit.rb

$ git stash --keep-index
Naka-save na gumaganang direktoryo at estado ng indeks WIP sa master: 1b65b17 idinagdag sa indeks na file
Ang HEAD ngayon ay nasa 1b65b17 idinagdag sa indeks na file

$ git status -s
M  index.html
----

Iba pang karaniwan na bagay na gugustuhin mo sa stash ay para i-stash ang hindi sinubaybayan na mga file pati na rin ang sinibaybayan.
Bilang default, ang `git stash` ay mag-stash lamang ng binagong at naka-stage na _tracked_ files.
Kung tinutukoy mo ang `--include-untracked` o `-u`, isasama ng Git ang mga file na hindi sinubaybayan sa nilikhang stash.

[source,console]
----
$ git status -s
M  index.html
 M lib/simplegit.rb
?? new-file.txt

$ git stash -u
Naka-save na gumaganang direktoryo at estado ng indeks WIP sa master: 1b65b17 idinagdag ang indeks na file
Ang HEAD ngayon ay nasa 1b65b17 na idinagdag ang indeks na file

$ git status -s
$
----

Sa wakas, kung ikaw ay nagtutukoy ng flag na `--patch`, hindi i-stash ng Git ang lahat na binago ngunit sa halip ay mag-prompt sa iyo kung alin ang mga pagbabago na gusto mong i-stash at kung ano ang gusto mo na panatilihin sa iyong gumaganang direktoryo.

[source,console]
----
$ git stash --patch
diff --git a/lib/simplegit.rb b/lib/simplegit.rb
index 66d332e..8bb5674 100644
--- a/lib/simplegit.rb
+++ b/lib/simplegit.rb
@@ -16,6 +16,10 @@ class SimpleGit
         return `#{git_cmd} 2>&1`.chomp
       end
     end
+
+    def show(treeish = 'master')
+      command("git show #{treeish}")
+    end

 end
 test
I-stash ang hunk na ito [y,n,q,a,d,/,e,?]? y

Naka-save na gumaganang direktoryo at estado ng indeks WIP sa master: 1b65b17 idinagdag ang indeks na file
----

==== Creating a Branch from a Stash

If you stash some work, leave it there for a while, and continue on the branch from which you stashed the work, you may have a problem reapplying the work.
If the apply tries to modify a file that you’ve since modified, you’ll get a merge conflict and will have to try to resolve it.
If you want an easier way to test the stashed changes again, you can run `git stash branch <branch>`, which creates a new branch for you with your selected branch name, checks out the commit you were on when you stashed your work, reapplies your work there, and then drops the stash if it applies successfully:

[source,console]
----
$ git stash branch testchanges
M	index.html
M	lib/simplegit.rb
Switched to a new branch 'testchanges'
On branch testchanges
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

	modified:   index.html

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   lib/simplegit.rb

Dropped refs/stash@{0} (29d385a81d163dfd45a452a2ce816487a6b8b014)
----

This is a nice shortcut to recover stashed work easily and work on it in a new branch.

[[_git_clean]]
==== Cleaning your Working Directory

Finally, you may not want to stash some work or files in your working directory, but simply get rid of them.
The `git clean` command will do this for you.

Some common reasons for this might be to remove cruft that has been generated by merges or external tools or to remove build artifacts in order to run a clean build.

You'll want to be pretty careful with this command, since it's designed to remove files from your working directory that are not tracked.
If you change your mind, there is often no retrieving the content of those files.
A safer option is to run `git stash --all` to remove everything but save it in a stash.

Assuming you do want to remove cruft files or clean your working directory, you can do so with `git clean`.
To remove all the untracked files in your working directory, you can run `git clean -f -d`, which removes any files and also any subdirectories that become empty as a result.
The `-f` means 'force' or "really do this".

If you ever want to see what it would do, you can run the command with the `-n` option, which means ``do a dry run and tell me what you _would_ have removed''.

[source,console]
----
$ git clean -d -n
Would remove test.o
Would remove tmp/
----

By default, the `git clean` command will only remove untracked files that are not ignored.
Any file that matches a pattern in your `.gitignore` or other ignore files will not be removed.
If you want to remove those files too, such as to remove all `.o` files generated from a build so you can do a fully clean build, you can add a `-x` to the clean command.

[source,console]
----
$ git status -s
 M lib/simplegit.rb
?? build.TMP
?? tmp/

$ git clean -n -d
Would remove build.TMP
Would remove tmp/

$ git clean -n -d -x
Would remove build.TMP
Would remove test.o
Would remove tmp/
----

If you don't know what the `git clean` command is going to do, always run it with a `-n` first to double check before changing the `-n` to a `-f` and doing it for real.
The other way you can be careful about the process is to run it with the `-i` or ``interactive'' flag.

This will run the clean command in an interactive mode.

[source,console]
----
$ git clean -x -i
Would remove the following items:
  build.TMP  test.o
*** Commands ***
    1: clean                2: filter by pattern    3: select by numbers    4: ask each             5: quit
    6: help
What now>
----

This way you can step through each file individually or specify patterns for deletion interactively.

[NOTE]
====
There is a quirky situation where you might need to be extra forceful in asking Git to clean your working directory.
If you happen to be in a working directory under which you've copied or cloned other Git repositories (perhaps as submodules), even `git clean -fd` will refuse to delete those directories.
In cases like that, you need to add a second `-f` option for emphasis.
====
