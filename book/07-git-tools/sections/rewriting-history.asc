[[_rewriting_history]]
=== Pagsulat muli ng Kasaysayan

Maraming beses, kapag ikaw ay nagtratrabaho gamit ang Git, baka gusto mong baguhin ang iyong lokal commit na kasaysayan.
Isa sa dakilang mga bagay tungkol sa Git ay nagbibigay-daan ito sa iyo upang gumawa ng mga desisyon sa huling posibleng sandali.
Maaari kang magpasya kung anong mga file ang papunta sa kung saang mga commit bago ka magsagawa ng commit sa stanging na lugar, maaari kang magpasya na hindi ibig sabihin na ikaw ay nagtratrabaho sa isang bagay pa gamit ang `git stash`, at maaari mong muling isulat ang mga commit na nangyari na para sila ay magmukha na nangyari sa ibang paraan.
Maaaring sangkot ang pagbabagot ng pagkasunod-sunod ng mga commit, pagbabago ng mga mensahe o pagbabago ng mga file sa isang commit, pag-squash nang magkasama o paghihiwalay na mga commit, o ang pag-alis ng mga commit sa lahat -- lahat ng bago mo ibahagi sa iyong trabaho sa iba.

Sa seksyon ito, makikita mo kung paaano gagawin ang mga gawaing ito upang makagawa ka ng iyong kasaysayan na magmukha sa gusto mong unang iyong ibinahagi sa iba.

[TANDAAN]
====
Isa sa kardinal na mga patakaran sa Git ay ang, mula ng maraming trabaho ay ang lokal na nasa loob ng iyong clone, meron kang isang magandang pakikitungo sa kalayaan upang sumulat muli ng iyong kasaysayan ng _naka-lokal_.
Gayunpaman, minsan ikaw ang nag-push ng iyong trabaho, ito ay isang ibang kwento sa kabuuan, at ikaw ay dapat kilalanin ang na-push na trabaho bilang huli maliban kung ikaw ay merong magandang dahilan upang baguhin ito.
Sa madaling salita, ikaw ay dapat umiwas sa pag-push ng iyong tranaho hanggang ikaw ay masaya nito at handang ibahagi sa buong mundo.
====

[[_git_amend]]
==== Pagbabago sa Huling Commit

Pagbabago ng iyong pinakabagong commit ay marahil nagsusulat muli ng kasaysayan na gagawin mo.
Madalas mong gustong gawin ang dalawang pangunahing mga bagay sa iyong huling commit: baguhin lang ang commit na mensahe, o baguhin ang aktwal na laman sa commit sa pamamagitan ng pagdaragdag, pag-alis at pagbago ng mga file.

Kung ikaw ay gusto lamang magbago ng iyong huling commit na mensahe, iyan ay madali:

[source,console]
----
$ git commit --amend
----

Ang utos sa itaas ay nagkakarga ng mga nakaraang commit na mensahe sa editor na sesyon, kapag ikaw ay gumawa ng mga pagbabago sa mensahe, i-save ang mga pagbabagong iyon at lumabas.
Kapag ikaw ay nag-save at nagsara sa editor, ang editor ay nagsusulat ng isang bagong commit na naglalaman sa pinakabago na commit na mensahe at ginagawa itong iyong bagong huling commit.

Kung, sa kabilang banda, ikaw ay gustong magbago ng aktwal na _nilalaman_ sa iyong huling commit, ang proseso ay gumagana talaga sa parehong paraan -- una gumawa ng mga pagbabago na sa tingin mo ay nakalimutan, i-stage ang mga pagbabagong iyon, at ang kasunod na `git commit --amend` _ay napapalit_ sa huling commit na iyon sa iyong bago, na pinabuting commit.

Kailangan mong maging maingat sa pamamaraang iyong dahil sa pagbago ng mga pagbabago sa SHA-1 ng commit.
Ito ay tulad ng isang maliit na rebase -- huwag baguhin ang iyong huling commit kung ikaw ay tapos na na-push ito.

[TANDAAN]
.Isang nabago na commit ay maaaring (o hindi maaaring) nangangailangan ng pagbago sa mensahe ng commit
====
Kapag iyong binago ang commit, mayroon kang pagkakataon na baguhin ang kapwa commit na mensahe at ang nilalaman sa commit.
Kung ikaw ay nagbago sa nilalaman sa commit na kalahatan, ikaw ay dapat halos tiyak sa pagbago sa commit sa mensahe upang sumasalamin sa nabago na nilalaman.

Sa kabilang banda, kung ang iyong pagbabago ay nag-aangkop ng walang halaga (pag-ayos sa isang hangal na pag-type o pagdagdag ng isang file na iyong nakalimutan ma-stage) tulad ng sa mas maagang commit na mensahe ay mabuti lang, magagawa mo lang na baguhin, i-stage sila, at iwasan ang hindi kinakailangan na sesyon ng editor na ganap na may:

[source,console]
----
$ git commit --amend --no-edit
----

====

[[_changing_multiple]]
==== Pagbabago sa Maramihang Commit na mga Mensahe

Upang baguhin ang isang commit na iyon na mas malayo sa iyong kasaysayan, ikaw ay dapat lumipat sa higit na kumplikadong mga kasangkapan.
Ang Git ay walang pagbabago-kasaysayan na kasangkapan, ngunit maaari mong gamitin ang rebase na kasangkapan sa mga serye ng mga commit papunta sa HEAD sila ay orihinal batay sa halip na paglipat sa kanila na para sa isa pa.
Gamit ang interactive na rebase na kasangkapan, maaari mong itigil pagkatapos ng bawat commit na gusto mong baguhin at palitan ang mensahe, magdagdag ng mga file, o gumawa ng gusto mong gawin.
Maaari mong patakbuhin ang rebase nang interactive sa pamamagitan sa pagdagdag ng `-i` na opsyon sa `git rebase`.
Dapat mong ipahiwatig kung gaano kalayo ang gusto mong isulat muli sa mga commit sa pamamagitan sa pagsabi ng utos na kung saan ang commit ay nag-rebase nito.

Halimbawa, kung gusto mong baguhin ang huling tatlong commit na mga mensahe, o anuman sa mga commit na mensahe sa grupong iyon, punan mo yun bilang isang argumento sa `git rebase -i` at ang magulang sa huling commit na gusto mong baguhin, na kung saan ay ang `HEAD~2^` o `HEAD~3`.
Maaaring mas madali itong matandaan ang `~3` dahil ikaw ay sinusubukang mag-edit sa huling tatlong mga commit, ngunit panataliin sa isip na ikaw ay tunay na nagtatalaga ng apat na mga commit nung nakaraan, ang magulang sa huling commit na gusto mong i-edit:

[source,console]
----
$ git rebase -i HEAD~3
----

Muling tandaan na ito ay isang rebase na utos – sa bawat commit na kasama sa lawak ng `HEAD~3..HEAD` ay masusulatang muli, kung ikaw ay nagbago sa mensahe o hindi.
Hindi nagsasali ng anumang commit na iyong na-push na sa sentral server – paggawa nito ay malilito ang ibang mga developer sa pamamagitan ng pagbigay ng isang alternatibong bersyon sa parehong pagbabago.

Pagtatakbo nitong utos ay nagbigigay sayo ng listahan ng mga commit sa iyong text editor na tulad nito:

[source,console]
----
pick f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file

# Rebase 710f0f8..a5f4a0d onto 710f0f8
#
# Commands:
#  p, pick = use commit
#  r, reword = use commit, but edit the commit message
#  e, edit = use commit, but stop for amending
#  s, squash = use commit, but meld into previous commit
#  f, fixup = like "squash", but discard this commit's log message
#  x, exec = run command (the rest of the line) using shell
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out
----

Ito ay importanteng tandaan na ang mga commit na ito ay nakalista sa kabaligtaran na pagkasunod-sunod kaysa sa normal na nakikita sa paggamit ng `log` na utos.
Kung ikaw ay nagpapatakbo ng `log`, ikaw ay makakita ng isang bagay na tulad nito:

[source,console]
----
$ git log --pretty=format:"%h %s" HEAD~3..HEAD
a5f4a0d added cat-file
310154e updated README formatting and added blame
f7f3f6d changed my name a bit
----

Pansinin ang baligtad na pagkasunod-sunod.
Ang interactive na rebase ay nagbibigay sa iyo ng isang script na ito ay tatakbo.
Ito ay nag-uumpisa sa commit na iyong itinukoy sa command line (`HEAD~3`) at i-replay ang mga pagbabago na ipinakilala sa bawat mga commit nito mula sa taas hanggang sa ibaba.
Ito ay naglilista sa pinakamatanda sa itaas, sa halip na ang pinakabago, dahil iyong ang unang mai-reply.

Ikaw ay kailangang mag-edit sa script upang tumigil ang commit na gusto mong i-edit.
Upang gawin ito, baguhin ang salitang `pumili' sa salitang `edit' para sa bawat mga commit na gusto mo na script upang itigil ito pagkatapos.
Halimbawa, upang baguhin lamang ang pangatlong commit na mensahe, baguhin mo ang file upang magmukhang ganito:

[source,console]
----
edit f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file
----

Kapag ikaw ay nag-save at lumabas sa editor, ang Git ay umuulit sa iyo pabalik sa huling commit sa listahan na iyon at naglaglag sa iyo sa command line na may sumusunod na mensahe:

[source,console]
----
$ git rebase -i HEAD~3
Stopped at f7f3f6d... changed my name a bit
You can amend the commit now, with

       git commit --amend

Once you’re satisfied with your changes, run

       git rebase --continue
----

Ang mga pagtuturong ito ay nagsasabi sa iyo ng eksakto kung ano ang gagawin.
Uri

[source,console]
----
$ git commit --amend
----

Baguhin ang commit na mensahe, at lumabas ang editor.
Pagkatapos, patakbuhin ang

[source,console]
----
$ git rebase --continue
----

Ang utos na ito ay mag-apply sa ibang dalawang mga commit na awtomatiko, at pagkatapos ay ikaw ay natapos na.
Kung ikaw ay nagpalit ng pagkuha sa pag-edit sa maraming mga linya, maaari mong ulitin ang mga hakbang na ito sa bawat commit na iyong binago sa edit.
Bawat oras, ang Git ay hihinto , hayaan mong baguhin ang commit, at patuloy kapag ikaw ay natapos.

==== Pagsunod-sunod ng mga Commit

Maaari mong ring gamitin ang interactive na mga rebase upang isunod-sunod o tanggalin ang mga commit kabuuan.
Kung gusto mong alisin ang ``added cat-file'' na commit at baguhin ang pagkasunod-sunod na kung saan ang ibang dalawang mga commit ay ipinakilala, maaari mong palitan ang rebase na script mula dito

[source,console]
----
pick f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file
----

para dito:

[source,console]
----
pick 310154e updated README formatting and added blame
pick f7f3f6d changed my name a bit
----

Kapag ikaw ay nag-save at lumabas sa editor, ang Git ay nag-uulit ng iyong branch sa magulang ng mga commit, naaangkop sa `310154e` at pagkatapos ang `f7f3f6d`, at pagkatapos ay huminto.
Ikaw ay epektibong nagbago sa pagkasunod-sunod ng mga commit at alisin ang ``added cat-file'' ang commit na ganap.

[[_squashing]]
==== Pag-squashng mga Commit

Ito rin ay posible upang kumuha ng isang serye ng mga commit at ang i-squash sila pababa ng isang solong commit na may interactive na pag-rebase na kasangkapan.
Ang script ay naglalagay ng matulungin na mga pagtuturo sa mensahe ng rebase:

[source,console]
----
#
# Commands:
#  p, pick = use commit
#  r, reword = use commit, but edit the commit message
#  e, edit = use commit, but stop for amending
#  s, squash = use commit, but meld into previous commit
#  f, fixup = like "squash", but discard this commit's log message
#  x, exec = run command (the rest of the line) using shell
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out
----

Kung, sa halip ay ang ``pick'' o ``edit'', na iyong itinuring sa halip na ``squash'', ang Git naaangkop sa bawat pagbabago at paglipat ng direkta bago ito at gumagawa ng merge na commit na mansahe na magkasama.
Kaya, kung gusto mong gumawa ng isang solong commit para sa tatlong mga commit, gumawa ka ng script na tulad nito:

[source,console]
----
pick f7f3f6d changed my name a bit
squash 310154e updated README formatting and added blame
squash a5f4a0d added cat-file
----

Kapag ikaw ay nag-save at lumabas sa editor, ang Git ay naaangkop sa lahat ng tatlong mga pagbabago at pagkatapos binbalik mo sa editor upang i-merge ang tatlong commit na mga mensahe:

[source,console]
----
# This is a combination of 3 commits.
# The first commit's message is:
changed my name a bit

# This is the 2nd commit message:

updated README formatting and added blame

# This is the 3rd commit message:

added cat-file
----

Kapag na-save na ito, mayroon kang isang solong commit na ipinakilala sa mga pagbabago sa lahat ng tatlong nakaraan na mga commit.

==== Splitting a Commit

Splitting a commit undoes a commit and then partially stages and commits as many times as commits you want to end up with.
For example, suppose you want to split the middle commit of your three commits.
Instead of ``updated README formatting and added blame'', you want to split it into two commits: ``updated README formatting'' for the first, and ``added blame'' for the second.
You can do that in the `rebase -i` script by changing the instruction on the commit you want to split to ``edit'':

[source,console]
----
pick f7f3f6d changed my name a bit
edit 310154e updated README formatting and added blame
pick a5f4a0d added cat-file
----

Then, when the script drops you to the command line, you reset that commit, take the changes that have been reset, and create multiple commits out of them.
When you save and exit the editor, Git rewinds to the parent of the first commit in your list, applies the first commit (`f7f3f6d`), applies the second (`310154e`), and drops you to the console.
There, you can do a mixed reset of that commit with `git reset HEAD^`, which effectively undoes that commit and leaves the modified files unstaged.
Now you can stage and commit files until you have several commits, and run `git rebase --continue` when you’re done:

[source,console]
----
$ git reset HEAD^
$ git add README
$ git commit -m 'updated README formatting'
$ git add lib/simplegit.rb
$ git commit -m 'added blame'
$ git rebase --continue
----

Git applies the last commit (`a5f4a0d`) in the script, and your history looks like this:

[source,console]
----
$ git log -4 --pretty=format:"%h %s"
1c002dd added cat-file
9b29157 added blame
35cfb2b updated README formatting
f3cc40e changed my name a bit
----

Once again, this changes the SHA-1s of all the commits in your list, so make sure no commit shows up in that list that you’ve already pushed to a shared repository.

==== The Nuclear Option: filter-branch

There is another history-rewriting option that you can use if you need to rewrite a larger number of commits in some scriptable way – for instance, changing your email address globally or removing a file from every commit.
The command is `filter-branch`, and it can rewrite huge swaths of your history, so you probably shouldn’t use it unless your project isn’t yet public and other people haven’t based work off the commits you’re about to rewrite.
However, it can be very useful.
You’ll learn a few of the common uses so you can get an idea of some of the things it’s capable of.

[[_removing_file_every_commit]]
===== Removing a File from Every Commit

This occurs fairly commonly.
Someone accidentally commits a huge binary file with a thoughtless `git add .`, and you want to remove it everywhere.
Perhaps you accidentally committed a file that contained a password, and you want to make your project open source.
`filter-branch` is the tool you probably want to use to scrub your entire history.
To remove a file named `passwords.txt` from your entire history, you can use the `--tree-filter` option to `filter-branch`:

[source,console]
----
$ git filter-branch --tree-filter 'rm -f passwords.txt' HEAD
Rewrite 6b9b3cf04e7c5686a9cb838c3f36a8cb6a0fc2bd (21/21)
Ref 'refs/heads/master' was rewritten
----

The `--tree-filter` option runs the specified command after each checkout of the project and then recommits the results.
In this case, you remove a file called `passwords.txt` from every snapshot, whether it exists or not.
If you want to remove all accidentally committed editor backup files, you can run something like `git filter-branch --tree-filter 'rm -f *~' HEAD`.

You’ll be able to watch Git rewriting trees and commits and then move the branch pointer at the end.
It’s generally a good idea to do this in a testing branch and then hard-reset your master branch after you’ve determined the outcome is what you really want.
To run `filter-branch` on all your branches, you can pass `--all` to the command.

===== Making a Subdirectory the New Root

Suppose you’ve done an import from another source control system and have subdirectories that make no sense (`trunk`, `tags`, and so on).
If you want to make the `trunk` subdirectory be the new project root for every commit, `filter-branch` can help you do that, too:

[source,console]
----
$ git filter-branch --subdirectory-filter trunk HEAD
Rewrite 856f0bf61e41a27326cdae8f09fe708d679f596f (12/12)
Ref 'refs/heads/master' was rewritten
----

Now your new project root is what was in the `trunk` subdirectory each time.
Git will also automatically remove commits that did not affect the subdirectory.

===== Changing Email Addresses Globally

Another common case is that you forgot to run `git config` to set your name and email address before you started working, or perhaps you want to open-source a project at work and change all your work email addresses to your personal address.
In any case, you can change email addresses in multiple commits in a batch with `filter-branch` as well.
You need to be careful to change only the email addresses that are yours, so you use `--commit-filter`:

[source,console]
----
$ git filter-branch --commit-filter '
        if [ "$GIT_AUTHOR_EMAIL" = "schacon@localhost" ];
        then
                GIT_AUTHOR_NAME="Scott Chacon";
                GIT_AUTHOR_EMAIL="schacon@example.com";
                git commit-tree "$@";
        else
                git commit-tree "$@";
        fi' HEAD
----

This goes through and rewrites every commit to have your new address.
Because commits contain the SHA-1 values of their parents, this command changes every commit SHA-1 in your history, not just those that have the matching email address.
