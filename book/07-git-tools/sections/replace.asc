[[_replace]]
=== Pagpapalit

Tulad ng aming binigyan diin noon, ang mga bagay sa Git na bagay na database na hindi nagbabago, ngunit ang ay nagbibigay ng interesadong paraan upang _magpanggap_ para magpalit ng mga bagay sa kanyang database na may ibang mga bagay.

Ang `replace` na utos ay hinahayaan kang tumukoy ng isang bagay sa Git at sabihin mo "sa tuwing tinutikoy mo _itong_ bagay, ay nagpapanggap na ito ay _ibang_ bagay".
Ito ay pinaka-karaniwang kapaki-pakinabang para sa pagpalit ng isang commit sa iyong kasaysayan na sa isa pang walang muling maitayo sa buong kasaysayan na may, sinasabi mong, `git filter-branch`.

Halimbawa, sabihin natin na meron kang isang malaking code sa iyong kasaysayan at gusto mong hatiin ang iyong repositoryo sa isang maikling kasaysayan para sa bagong mga developer at isang mas matagal at mataas na kasaysayan para sa taong interesado sa pagmimina ng datos.
Maaari mong i-graft ang isang kasaysayan na papunta sa iba sa pamamagitan ng "pagpapalit" sa pinakamaagang commit sa bagong linya na may pinakabagong commit sa mas matanda.
Ito ay maganda dahil ang ibig sabihin nito ay wala ka talagang na sulat muli sa bawat commit sa bagong kasaysayan, gaya ng gusto mo na normal na meron kang gagawin upang makasali sa kanila na magkasama (dahil ang porsyento ay nakakaapekto sa SHA-1s).

Subukan nati ito.
Kumuha tayo ng isang umiiral na repositoryo, hatiin ito sa dalawang repositoryo, isa sa pinakabago at isa sa makasaysayan, at pagkatapos tingnan natin kung papaano natin ma mapagsama sila sa pagbabago sa pinakabagong repositoryo na SHA-1 na mga halaga sa pamamagitan ng `replace`.

Gagamitan namin ng isang simpleng repositoryo na may limang simpleng mga commit:

[source,console]
----
$ git log --oneline
ef989d8 fifth commit
c6e1e95 fourth commit
9c68fdc third commit
945704c second commit
c1822cf first commit
----

Gusto naming masira ito sa dalawang linya ng kasaysayan.
Isang linya papunta mula sa commit na isa hanggang sa commit na apat - at iyon ang magiging kasaysayan.
Ang pangalawang linya ay magiging mga commit na apat at lima - iyon ay magiging kamakailang kasaysayan.

image::images/replace1.png[]

Kahit, ang paglikha ng makasaysayang kasaysayan ay madali, maaari lang nating lagyan ng branch sa kasaysayan at pagkatapos i-push ang branch na iyon sa master na branch sa isang bagong malayong repositoryo.

[source,console]
----
$ git branch history c6e1e95
$ git log --oneline --decorate
ef989d8 (HEAD, master) fifth commit
c6e1e95 (history) fourth commit
9c68fdc third commit
945704c second commit
c1822cf first commit
----

image::images/replace2.png[]

Ngayon maaari na tayong mag-push sa bagong `history` na branch sa `master` na branch sa ating bagong repositoryo:

[source,console]
----
$ git remote add project-history https://github.com/schacon/project-history
$ git push project-history history:master
Counting objects: 12, done.
Delta compression using up to 2 threads.
Compressing objects: 100% (4/4), done.
Writing objects: 100% (12/12), 907 bytes, done.
Total 12 (delta 0), reused 0 (delta 0)
Unpacking objects: 100% (12/12), done.
To git@github.com:schacon/project-history.git
 * [new branch]      history -> master
----

OK, kaya ang ating kasaysayan ay i-publish.
Ngayon ang mas mahirap na parte ay ang pagbawas sa ating pinakabagong kasaysayan na pababa kaya maliit ito.
Kailagan natin ng isang pagsasapaw para tayo ay makapagpalit ng isang commit sa isa na may katumbas na commit sa iba, kaya pupunta tayo sa pagbawas nito sa mga na commit lamang na apat at lima (kayta ang commit na apat na mga pagsasapaw).

[source,console]
----
$ git log --oneline --decorate
ef989d8 (HEAD, master) fifth commit
c6e1e95 (history) fourth commit
9c68fdc third commit
945704c second commit
c1822cf first commit
----

Ito ay kapaki-pakinabang sa kasong ito upang lumikha ng base na commit na mayroong mga pagtuturo kung paano palawakin ang kasaysayan, kaya ang ibang developer at malaman kung ano ang gagawin kung sila ay unang pumindot sa nabawas na kasaysayan at kailangan pa.
Kaya, kung ano ang gagawin natin ay ang paglikha ng pasiunang commit na bagay bilang ating base na punto na may mga pagtuturo, pagkatapos ang rebase sa natitirang mga commit (apat at lima) sa itaas nito.

Upang gawin iyon, kailangan natin pumili ng isang punto para hatiin sa, na para sa amin ay ang pangatlong commit, na kung saan ay `9c68fdc` sa SHA-speak.
Kaya, sa aming base commit ay magiging batay sa tree na iyon.
Maaari tayong lumikha ng ating base commit gamit ang `commit-tree` na utos, na kung saan ay kumukuha ng isang tree at nagbigay sa atin na isang napakabagong, walang magulang na commit na bagay na SHA-1 sa likod.

[source,console]
----
$ echo 'get history from blah blah blah' | git commit-tree 9c68fdc^{tree}
622e88e9cbfbacfb75b5279245b9fb38dfea10cf
----

[NOTE]
=====
The `commit-tree` command is one of a set of commands that are commonly referred to as 'plumbing' commands.
These are commands that are not generally meant to be used directly, but instead are used by *other* Git commands to do smaller jobs.
On occasions when we're doing weirder things like this, they allow us to do really low-level things but are not meant for daily use.
You can read more about plumbing commands in <<_git_internals#_plumbing_porcelain>>
=====

image::images/replace3.png[]

OK, so now that we have a base commit, we can rebase the rest of our history on top of that with `git rebase --onto`.
The `--onto` argument will be the SHA-1 we just got back from `commit-tree` and the rebase point will be the third commit (the parent of the first commit we want to keep, `9c68fdc`):

[source,console]
----
$ git rebase --onto 622e88 9c68fdc
First, rewinding head to replay your work on top of it...
Applying: fourth commit
Applying: fifth commit
----

image::images/replace4.png[]

OK, so now we've re-written our recent history on top of a throw away base commit that now has instructions in it on how to reconstitute the entire history if we wanted to.
We can push that new history to a new project and now when people clone that repository, they will only see the most recent two commits and then a base commit with instructions.

Let's now switch roles to someone cloning the project for the first time who wants the entire history.
To get the history data after cloning this truncated repository, one would have to add a second remote for the historical repository and fetch:

[source,console]
----
$ git clone https://github.com/schacon/project
$ cd project

$ git log --oneline master
e146b5f fifth commit
81a708d fourth commit
622e88e get history from blah blah blah

$ git remote add project-history https://github.com/schacon/project-history
$ git fetch project-history
From https://github.com/schacon/project-history
 * [new branch]      master     -> project-history/master
----

Now the collaborator would have their recent commits in the `master` branch and the historical commits in the `project-history/master` branch.

[source,console]
----
$ git log --oneline master
e146b5f fifth commit
81a708d fourth commit
622e88e get history from blah blah blah

$ git log --oneline project-history/master
c6e1e95 fourth commit
9c68fdc third commit
945704c second commit
c1822cf first commit
----

To combine them, you can simply call `git replace` with the commit you want to replace and then the commit you want to replace it with.
So we want to replace the "fourth" commit in the master branch with the "fourth" commit in the `project-history/master` branch:

[source,console]
----
$ git replace 81a708d c6e1e95
----

Now, if you look at the history of the `master` branch, it appears to look like this:

[source,console]
----
$ git log --oneline master
e146b5f fifth commit
81a708d fourth commit
9c68fdc third commit
945704c second commit
c1822cf first commit
----

Cool, right?  Without having to change all the SHA-1s upstream, we were able to replace one commit in our history with an entirely different commit and all the normal tools (`bisect`, `blame`, etc) will work how we would expect them to.

image::images/replace5.png[]

Interestingly, it still shows `81a708d` as the SHA-1, even though it's actually using the `c6e1e95` commit data that we replaced it with.
Even if you run a command like `cat-file`, it will show you the replaced data:

[source,console]
----
$ git cat-file -p 81a708d
tree 7bc544cf438903b65ca9104a1e30345eee6c083d
parent 9c68fdceee073230f19ebb8b5e7fc71b479c0252
author Scott Chacon <schacon@gmail.com> 1268712581 -0700
committer Scott Chacon <schacon@gmail.com> 1268712581 -0700

fourth commit
----

Remember that the actual parent of `81a708d` was our placeholder commit (`622e88e`), not `9c68fdce` as it states here.

Another interesting thing is that this data is kept in our references:

[source,console]
----
$ git for-each-ref
e146b5f14e79d4935160c0e83fb9ebe526b8da0d commit	refs/heads/master
c6e1e95051d41771a649f3145423f8809d1a74d4 commit	refs/remotes/history/master
e146b5f14e79d4935160c0e83fb9ebe526b8da0d commit	refs/remotes/origin/HEAD
e146b5f14e79d4935160c0e83fb9ebe526b8da0d commit	refs/remotes/origin/master
c6e1e95051d41771a649f3145423f8809d1a74d4 commit	refs/replace/81a708dd0e167a3f691541c7a6463343bc457040
----

This means that it's easy to share our replacement with others, because we can push this to our server and other people can easily download it.
This is not that helpful in the history grafting scenario we've gone over here (since everyone would be downloading both histories anyhow, so why separate them?) but it can be useful in other circumstances.
